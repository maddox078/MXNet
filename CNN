using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO.Packaging;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Security.Cryptography.Xml;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms.VisualStyles;
using System.Xml.Serialization;

namespace MaddoxNET
{
    public class CNN
    {
        public ANN_Perf NeuralNetwork;
        public int ImageDimensions = 0;
        public double[][][][] Filters;
        public double[][][][] CurrentDeltas;
        public double[][][][] PrevDeltas;
        public double[][][][] FiltersM;
        public double[][][][] FiltersV;
        public double [][][][] FeatureMaps;
        public double [][][][] MaxFeatureMaps;
        public double [][][][] PrePoolFeatureMaps;
        public double [][][][] RawFeatureMaps;
        public double [][][][] DerivativeFeatureMaps;
        public double [][][][] Errors;
        public double [][][][] MaxPoolGradients;
        public double [] SampleErrors;
        public double [] SampleWeightDeltas;
        public double[] SampleActivations;
        public double ReLUConst = 0.01;
        public double LearningRate = 0;
        public int [] PoolingSchedule;
        public int [] StrideSchedule;
        public double FilterVariance = 0;
        public double FilterMean = 0;
        public int GlobalIterator = 0;
        public int[] CNNActivationFunctionIDs;

        public CNN(int[] LayerCounts,double [][][][] FilterList,int[] ActivationIDs, int[] CNNActivationIDs,int[] PoolingSchedule, int[] StrideSchedule,int ImageDim, double LearningRate,double MomentumFactor,int WeightInitializationID=0)
        {
            int[] TempList;
            int[] TempList2;
            double[][] PrimaryFilter;
            int X = 0;
            double TempVal = ImageDim;

            this.ImageDimensions = ImageDim;

            this.NeuralNetwork = new ANN_Perf(LayerCounts, ActivationIDs, 2, LearningRate, MomentumFactor,WeightInitializationID);

            this.Filters = new double[FilterList.Length][][][];
            this.Filters = FilterList;

            this.CNNActivationFunctionIDs = CNNActivationIDs;
            this.PoolingSchedule = PoolingSchedule;
            this.StrideSchedule = StrideSchedule;
            InitializeNetwork();
            InitializeMV();
            InitializePooling();
        }

        public void InitializeMV()
        {
            int X = 0;
            int Y = 0;
            int Z = 0;
            int ZZ = 0;
            double[] TempListM;
            double[][] TempList2M;
            double[][][] TempList3M;
            double[] TempListV;
            double[][] TempList2V;
            double[][][] TempList3V;

            this.FiltersM = new double[this.Filters.Length][][][];
            this.FiltersV = new double[this.Filters.Length][][][];

            while (X < this.Filters.Length)
            {
                TempList3M = new double[this.Filters[X].Length][][];
                TempList3V = new double[this.Filters[X].Length][][];
                Y = 0;
                while(Y < this.Filters[X].Length)
                {
                    TempList2M = new double[this.Filters[X][Y].Length][] ;
                    TempList2V = new double[this.Filters[X][Y].Length][];
                    Z = 0;
                    while(Z < this.Filters[X][Y].Length)
                    {
                        TempListM = new double[this.Filters[X][Y].Length];
                        TempListV = new double[this.Filters[X][Y].Length];
                        ZZ = 0;
                        while(ZZ < this.Filters[X][Y][Z].Length)
                        {
                            TempListM[ZZ] = 0;
                            TempListV[ZZ] = 0;

                            ZZ++;
                        }

                        TempList2M[Z] = TempListM;
                        TempList2V[Z] = TempListV;

                        Z++;
                    }

                    TempList3M[Y] = TempList2M;
                    TempList3V[Y] = TempList2V;

                    Y++;
                }

                this.FiltersM[X] = TempList3M;
                this.FiltersV[X] = TempList3V;

                X++;
            }
        }


        public void ClearGradients()
        {
            int X = 0;
            int Y = 0;
            int Z = 0;
            int ZZ = 0;
            double[] Templist;
            double[][] TempList2;
            double[][][] TempList3;
            double[][][][] TempList4;

            TempList4 = new double[this.Filters.Length][][][];

            while (X < this.Filters.Length)
            {
                TempList3 = new double[this.Filters[X].Length][][];
                Y = 0;
                while (Y < this.Filters[X].Length)
                {
                    TempList2 = new double[this.Filters[X][Y].Length][];
                    Z = 0;
                    while (Z < this.Filters[X][Y].Length)
                    {
                        Templist = new double[this.Filters[X][Y][Z].Length];
                        ZZ = 0;
                        while (ZZ < this.Filters[X][Y][Z].Length)
                        {
                            Templist[ZZ] = 0;

                            ZZ++;
                        }

                        TempList2[this.Filters[X][Y].Length] = Templist;

                        Z++;
                    }

                    TempList3[Y] = TempList2;

                    Y++;
                }

                TempList4[X] = TempList3;

                X++;
            }

            this.CurrentDeltas = TempList4;
        }

        public void InitializeNetwork()
        {
            int X = 0;
            int Y = 0;
            int Z = 0;
            int ZZ = 0;
            Random Rnd = new Random(System.Guid.NewGuid().GetHashCode());
            double[][][] TempList3;
            double[][][] TempList4;
            double[][] TempErrors;
            double[][] TempWeights;
            double[][] TempFeatures;
            double[] TempList;
            double[] TempList6;
            double[][] TempList2;
            double[][] TempList5;
            bool Flag = false;
            int NewImageDim = this.ImageDimensions - this.Filters[0][0].Length + 1;

            this.Errors = new double[this.Filters.Length][][][];
            this.FeatureMaps = new double[this.Filters.Length][][][];
            this.RawFeatureMaps = new double[this.Filters.Length][][][];
            this.DerivativeFeatureMaps = new double[this.Filters.Length][][][];
            this.PrePoolFeatureMaps = new double[this.Filters.Length][][][];


            if (this.GlobalIterator == 0)
            {
                Flag = true;
                this.PrevDeltas = new double[this.Filters.Length][][][];
                this.CurrentDeltas = new double[this.Filters.Length][][][];
            }

            X = 0;
            //Filters
            while (X < this.FeatureMaps.Length)
            {
                TempList3 = new double[this.Filters[X].Length][][];
                TempList4 = new double[this.Filters[X].Length][][];
                Y = 0;
                while(Y < this.Filters[X].Length)
                {
                    TempList2 = new double[NewImageDim][];
                    TempList5 = new double[NewImageDim][];
                    Z = 0;

                    while(Z < NewImageDim)
                    {
                        TempList = new double[NewImageDim];
                        TempList6 = new double[NewImageDim];
                        ZZ = 0;
                        while(ZZ < NewImageDim)
                        {
                            TempList[ZZ] = 0;
                            //this.PrevDeltas.Add(0);

                            ZZ++;
                        }

                        TempList2[Z] = TempList;

                        Z++;
                    }

                    TempList3[Y] = TempList2;

                    Y++;
                }

                NewImageDim -= (this.Filters[X][0].Length + 1);

                this.Errors[X] = TempList3;
                this.FeatureMaps[X] = TempList4;
                

                X++;
            }


            if(Flag)
            {
                X = 0;
                while (X < this.Filters.Length)
                {
                    TempList3 = new double[this.Filters[X].Length][][];
                    TempList4 = new double[this.Filters[X].Length][][];
                    Y = 0;
                    while (Y < this.Filters[X].Length)
                    {
                        TempList2 = new double[this.Filters[X][0].Length][];
                        TempList5 = new double[this.Filters[X][0].Length][];
                        Z = 0;
                        while (Z < this.Filters[X][Y].Length)
                        {
                            TempList = new double[this.Filters[X][Y][Z].Length];
                            TempList6 = new double[this.Filters[X][Y][Z].Length];
                            ZZ = 0;
                            while (ZZ < this.Filters[X][Y][Z].Length)
                            {
                                TempList[ZZ] = 0;
                                TempList6[ZZ] = 0;

                                ZZ++;
                            }

                            TempList2[Z] = TempList;
                            TempList5[Z] = TempList6;

                            Z++;
                        }

                        TempList3[Y] = TempList2;
                        TempList4[Y] = TempList5;

                        Y++;
                    }

                    this.PrevDeltas[X] = TempList3;
                    this.CurrentDeltas[X] = TempList4;

                    X++;
                }
            }
        }


        public double[][][] ReshapeFullyConnectedLayer()
        {
            List<List<List<double>>> Outputs = new List<List<List<double>>>();
            List<double> TempList1 = new List<double>();
            List<List<double>> TempList2 = new List<List<double>>();
            int X = 0;

            while(X < this.NeuralNetwork.Activations[this.NeuralNetwork.Activations.Length - 1].Length)
            {
                if(X > 0 && X % this.ImageDimensions == 0)
                {
                    TempList2.Add(TempList1);
                    TempList1 = new List<double>();
                }

                if(TempList2.Count > 0 && TempList2.Count % this.ImageDimensions == 0)
                {
                    Outputs.Add(TempList2);
                    TempList2 = new List<List<double>>();
                }

                TempList1.Add(this.NeuralNetwork.Activations[this.NeuralNetwork.Activations.Length - 1][X]);

                X++;
            }

            //TempList2.Add(TempList1);
            //Outputs.Add(TempList2);

            return LayerMapsToArray(Outputs);
        }

        public double[][][] LayerMapsToArray(List<List<List<double>>> Inputs)
        {
            double[][][] Outputs = new double[Inputs.Count][][];
            double[][] SubOutputs;
            double[] SubSubOutputs;
            int X = 0;
            int Y = 0;
            int Z = 0;

            while(X < Inputs.Count)
            {
                SubOutputs = new double[Inputs[X].Count][];
                Y = 0;
                while(Y < Inputs[X].Count)
                {
                    SubSubOutputs = new double[Inputs[X][Y].Count];
                    Z = 0;
                    while(Z < Inputs[X][Y].Count)
                    {
                        SubSubOutputs[Z] = Inputs[X][Y][Z];

                        Z++;
                    }

                    SubOutputs[Y] = SubSubOutputs;

                    Y++;
                }

                Outputs[X] = SubOutputs;

                X++;
            }

            return Outputs;
        }

        public void FeedForwardGenerator(double[] Inputs, bool PoolFeatures, int OutputNormalization = 9, bool NormalizeOutputs = true)
        {
            double[][][] FinalInputs;
            double[][][] SubInputs;
            double[][][] SubInputs2;
            int X = 0;
            int Y = 0;
            int Z = 0;
            int ZZ = 0;

            this.FeatureMaps = new double[this.Filters.Length][][][] ;
            this.RawFeatureMaps = new double[this.Filters.Length][][][];
            this.DerivativeFeatureMaps = new double[this.Filters.Length][][][];
            this.PrePoolFeatureMaps = new double[this.Filters.Length][][][];

            this.NeuralNetwork.ForwardPropagate(Inputs, OutputNormalization, NormalizeOutputs);

            SubInputs = ReshapeTensor(this.NeuralNetwork.Activations[this.NeuralNetwork.Activations.Length - 1], this.Filters[0].Length);

            X = 0;
            while (X < this.Filters.Length)
            {
                if (X > 0)
                {
                    SubInputs = new double[this.FeatureMaps[X - 1].Length][][];
                    SubInputs = this.FeatureMaps[X - 1];
                }

                SubInputs = this.Convolve(SubInputs, this.Filters[X], this.StrideSchedule[X], false);

                this.DerivativeFeatureMaps[X] = this.ActivateDerivativeConvolutions(SubInputs, this.CNNActivationFunctionIDs[X]);
                this.RawFeatureMaps[X] = SubInputs;

                if (X >= 0)
                {
                    SubInputs = this.ActivateConvolutions(this.RawFeatureMaps[X], this.CNNActivationFunctionIDs[X]);
                }

                if (PoolFeatures)
                {
                    //SubInputs = this.PoolLayer(SubInputs, X, this.PoolingSchedule[X], true);
                }


                this.FeatureMaps[X] = SubInputs;

                X++;
            }           
        }

        public void InitializePooling()
        {
            int X = 0;
            int Y = 0;
            int A = 0;
            int B = 0;
            int C = 0;
            List<double> TempList1 = new List<double>();
            List<List<double>> TempList2 = new List<List<double>>();
            double[][] TempMap;
            double[][][] TempList3a;
            List<List<List<double>>> TempList3b = new List<List<List<double>>>();
            List<List<List<List<double>>>> TempList4a = new List<List<List<List<double>>>>();
            List<List<List<List<double>>>> TempList4b = new List<List<List<List<double>>>>();
            List<List<List<List<List<double>>>>> TempList5 = new List<List<List<List<List<double>>>>>();
            double Limit = this.ImageDimensions;
            double SubLimit = Limit;
            int LastDim = this.ImageDimensions;

            this.MaxPoolGradients = new double[this.Filters.Length][][][];

            while(X < this.Filters.Length)
            {
                LastDim = LastDim - this.Filters[X][0][0].Length + 1;
                TempList3a = new double[this.Filters[X].Length][][];
                Y = 0;
                while(Y < this.Filters[X].Length)
                {
                    TempMap = this.CreateEmptyMap(LastDim);

                    TempList3a[Y] = TempMap;

                    Y++;
                }

                this.MaxPoolGradients[X] = TempList3a;

                X++;
            }

        }

        public void FeedForward(double[][] Inputs,bool PoolFeatures,int OutputNormalization = 9,bool NormalizeOutputs = true)
        {
            List<List<List<List<double>>>> FinalInputs = new List<List<List<List<double>>>>();
            double[][][] SubInputs = new double[1][][];
            List<List<List<double>>> SubInputs2 = new List<List<List<double>>>();
            List<double> TempList = new List<double>();
            int X = 0;
            int Y = 0;
            int Z = 0;
            int ZZ = 0;

            SubInputs[0] = Inputs;

            X = 0;
            while (X < this.Filters.Length)
            {
                if(X == 0)
                {
                    SubInputs = this.Convolve(SubInputs, this.Filters[X], this.StrideSchedule[X], false);
                }
                else
                {
                    SubInputs = this.Convolve(this.FeatureMaps[X-1], this.Filters[X], this.StrideSchedule[X], false);
                }
                

                this.DerivativeFeatureMaps[X] = this.ActivateDerivativeConvolutions(SubInputs, this.CNNActivationFunctionIDs[X]);

                if(PoolFeatures)
                {
                    //SubInputs = this.PoolLayer(SubInputs, X, this.PoolingSchedule[X], true);
                }


                this.RawFeatureMaps[X] = SubInputs;

                if(X >= 0)
                {
                    SubInputs = this.ActivateConvolutions(this.RawFeatureMaps[X], this.CNNActivationFunctionIDs[X]);
                }

                this.FeatureMaps[X] = SubInputs;
                //this.FeatureMaps[X] = this.NormalizeDataSet(this.FeatureMaps[X], 3);

                X++;
            }

            //this.GlobalIterator++;

            this.NeuralNetwork.ForwardPropagate(this.Flatten3DVector(this.FeatureMaps[this.FeatureMaps.Length - 1]),OutputNormalization,NormalizeOutputs);
         }

        public double[][] ExpandVector(double[] Input)
        {
            int Dims = (int)Math.Sqrt(Input.Length);
            double[][] FinalOutput = new double[Dims][];
            List<List<double>> Output = new List<List<double>>();
            List<double> SubOutput = new List<double>();
            double[] SubAry;
            double[] SubSubAry;
            int X = 0;
            int Y = 0;
            int Z = 0;
            

            //Y = Input.Count;
            //X = 0;
            //while(X < Y - (Math.Pow(Dims,2)))
            //{
            //    Input.Add(0);

            //    X++;
            //}


            //This needs to make an x y grid of rgbs
            while (Z < Input.Length)
            {
                X = 0;

                SubOutput.Add(Input[Z]);

                if ((Z) % Dims == 0 && Z != 0)
                {
                    Output.Add(SubOutput);
                    SubOutput = new List<double>();
                }

                Z++;
            }

            FinalOutput = new double[Output.Count][];

            X = 0;
            while(X < Output.Count)
            {
                SubSubAry = new double[Output[X].Count];
                Y = 0;
                while(Y < Output[X].Count)
                {
                    SubSubAry[Y] = Output[X][Y];

                    Y++;
                }

                FinalOutput[X] = SubSubAry;

                X++;
            }

            return FinalOutput;
        }

        public double[][][] ReshapeErrorTensor()
        {
            int NeuronCount = this.FeatureMaps[this.FeatureMaps.Length - 1].Length;
            int FeatureMapDim = (int)(Math.Sqrt(this.NeuralNetwork.Activations[0].Length / NeuronCount));
            List<double> SubSubTempList = new List<double>();
            List<List<double>> SubTempList = new List<List<double>>();
            List<List<List<double>>> TempList = new List<List<List<double>>>();
            double[][][] FinalOutput;
            double[][] SubFinalOutput;
            double[] SubSubFinalOutput;
            int X = 0;
            int Y = 0;
            int Z = 0;

            while(X < this.NeuralNetwork.Errors[0].Length)
            {
                if(X > 0 && X % FeatureMapDim == 0)
                {
                    SubTempList.Add(SubSubTempList);
                    SubSubTempList = new List<double>();

                    if(SubTempList.Count % FeatureMapDim == 0)
                    {
                        TempList.Add(SubTempList);
                        SubTempList = new List<List<double>>();
                    }
                }               

                SubSubTempList.Add(this.NeuralNetwork.Errors[0][X]);

                X++;
            }

            SubTempList.Add(SubSubTempList);
            TempList.Add(SubTempList);

            FinalOutput = new double[TempList.Count][][];
            X = 0;
            while (X < TempList.Count)
            {
                SubFinalOutput = new double[TempList[X].Count][];
                Y = 0;
                while (Y < TempList[X].Count)
                {
                    SubSubFinalOutput = new double[TempList[X][Y].Count];
                    Z = 0;
                    while(Z < TempList[X][Y].Count)
                    {
                        SubSubFinalOutput[Z] = TempList[X][Y][Z];

                        Z++;
                    }

                    SubFinalOutput[Y] = SubSubFinalOutput;

                    Y++;
                }

                FinalOutput[X] = SubFinalOutput;

                X++;
            }


            return FinalOutput;
        }



        public double[][][] ElementWiseMultiply(double[][][] Input1, double[][][] Input2)
        {
            double[] SubSubRetVal;
            double[][] SubRetVal;
            double[][][] RetVal = new double[Input2.Length][][];
            int X = 0;
            int Y = 0;
            int Z = 0;

            while(X < Input1.Length)
            {
                SubRetVal = new double[Input1[X].Length][];
                Y = 0;
                while(Y < Input1[X].Length)
                {
                    SubSubRetVal = new double[Input1[X][Y].Length];
                    Z = 0;
                    while(Z < Input1[X][Y].Length)
                    {
                        if(X < Input2.Length && Y < Input2[0].Length && Z < Input2[0][0].Length)
                        {
                            SubSubRetVal[Z] = (Input1[X][Y][Z] * Input2[X][Y][Z]);
                        }
                        else
                        {
                            //SubSubRetVal.Add(Input1[X][Y][Z]);
                            SubSubRetVal[Z] = 0;
                        }



                        Z++;
                    }

                    SubRetVal[Y] = SubSubRetVal;

                    Y++;
                }

                RetVal[X] = SubRetVal;

                X++;
            }

            return RetVal;
        }

        public double[][] ElementWiseSummation(double[][] Input1, double[][] Input2)
        {
            double[] SubSubRetVal;
            double[][] SubRetVal = new double[Input1.Length][]; 
            int X = 0;
            int Y = 0;

            while (X < Input1.Length)
            {
                SubSubRetVal = new double[Input1[X].Length];
                Y = 0;
                while (Y < Input1[X].Length)
                {
                    SubSubRetVal[Y] = (Input1[X][Y] + Input2[X][Y]);

                    Y++;
                }

                SubRetVal[X] = SubSubRetVal;

                X++;
            }

            return SubRetVal;
        }

        public List<List<List<double>>> ResolveMaxPooling(List<List<List<double>>> InputLayer, int LayerID)
        {
            List<List<List<double>>> RetVal = new List<List<List<double>>>();
            List<List<double>> TempMap = new List<List<double>>();
            int X = 0;
            int Y = 0;
            int Z = 0;
            int A = 0;
            int B = 0;
            double GradientVal = 0;

            while (X < InputLayer.Count)
            {
                //TempMap = this.CreateEmptyMap(this.FeatureMaps[Math.Max(0, LayerID - 1)][0].Length - (this.Filters[LayerID][0].Length - 1));
                Y = 0;
                while (Y < InputLayer[X].Count)
                {
                    Z = 0;
                    while (Z < InputLayer[X][Y].Count)
                    {
                        A = 0;
                        while (A < this.PoolingSchedule[LayerID])
                        {
                            B = 0;
                            while (B < this.PoolingSchedule[LayerID])
                            {
                                if (Y * this.PoolingSchedule[LayerID] + A < TempMap.Count && Z * this.PoolingSchedule[LayerID] + B < TempMap.Count)
                                {
                                    TempMap[Y * this.PoolingSchedule[LayerID] + A][Z * this.PoolingSchedule[LayerID] + B] = (InputLayer[X][Y][Z] * this.MaxPoolGradients[LayerID][X][Y][Z]);
                                }


                                B++;
                            }

                            A++;
                        }


                        Z++;
                    }

                    Y++;
                }

                RetVal.Add(TempMap);

                X++;
            }

            return RetVal;
        }

        public double[][] PadMap(double[][] InputMap,int PaddingSize)
        {
            double[] TempList1;
            double[][] TempList2 = new double[InputMap.Length + (2 * PaddingSize)][];
            int X = 0;
            int Y = 0;

            while(X < InputMap.Length + (2 * PaddingSize))
            {
                TempList1 = new double[InputMap.Length + (2 * PaddingSize)];
                Y = 0;
                while(Y < InputMap.Length + (2 * PaddingSize))
                {
                    TempList1[Y] = 0;

                    Y++;
                }

                TempList2[X] = TempList1;

                X++;
            }

            X = 0;
            while(X < InputMap.Length)
            {
                Y = 0;
                while(Y < InputMap[X].Length)
                {
                    TempList2[X + PaddingSize][Y + PaddingSize] = InputMap[X][Y];

                    Y++;
                }

                X++;
            }

            return TempList2;
        }

        public double[][][] PadLayerMaps(double[][][] InputLayerMaps,int PaddingSize)
        {
            double[][][] RetVal = new double[InputLayerMaps.Length][][];
            int X = 0;

            while(X < InputLayerMaps.Length)
            {
                RetVal[X] = PadMap(InputLayerMaps[X], PaddingSize);

                X++;
            }

            return RetVal;
        }


        public double[][][] ReshapeTensor(double[] Input,int MapCount)
        {
            List<List<double>> TempMap = new List<List<double>>();
            List<List<List<double>>> Output = new List<List<List<double>>>();
            List<double> TempList = new List<double>();

            double[][][] FinalOutput;
            double[][] FinalTempMap;
            double[] FinalTempList;

            int X = 0;
            int Y = 0;
            int Z = 0;
            int MapDimensions = (int)Math.Sqrt((int)(Input.Length / MapCount));

            while(X < Input.Length)
            {
                if(X > 0 && X % MapDimensions == 0)
                {
                    TempMap.Add(TempList);
                    TempList = new List<double>();
                }

                if(TempMap.Count > 0 && TempMap.Count % MapDimensions == 0)
                {
                    Output.Add(TempMap);
                    TempMap = new List<List<double>>();
                }

                TempList.Add(Input[X]);

                X++;
            }

            TempMap.Add(TempList);
            Output.Add(TempMap);

            FinalOutput = new double[Output.Count][][];
            X = 0;
            while(X < Output.Count)
            {
                FinalTempMap = new double[Output[X].Count][];
                Y = 0;
                while(Y < Output[X].Count)
                {
                    FinalTempList = new double[Output[X][Y].Count];
                    Z = 0;
                    while(Z < Output[X][Y].Count)
                    {
                        FinalTempList[Z] = Output[X][Y][Z];

                        Z++;
                    }

                    FinalTempMap[Y] = FinalTempList;

                    Y++;
                }

                FinalOutput[X] = FinalTempMap;

                X++;
            }

            return FinalOutput;
        }

        public double[][][] CalculateGeneratorLoss(double DiscriminatorActivation,double DiscriminatorRawOutput)
        {
            double[][][] Outputs = new double[this.FeatureMaps[this.FeatureMaps.Length - 1].Length][][];
            double[][] TempList2;
            double[] TempList1;
            int X = 0;
            int Y = 0;
            int Z = 0;
            double TempVal = 0;

            while(Z < this.FeatureMaps[this.FeatureMaps.Length - 1].Length)
            {
                TempList2 = new double[this.FeatureMaps[this.FeatureMaps.Length - 1][Z].Length][];
                X = 0;
                while (X < this.FeatureMaps[this.FeatureMaps.Length - 1][Z].Length)
                {
                    TempList1 = new double[this.FeatureMaps[this.FeatureMaps.Length - 1][Z][X].Length];
                    Y = 0;
                    while (Y < this.FeatureMaps[this.FeatureMaps.Length - 1][Z][X].Length)
                    {
                        //TempVal = DiscriminatorActivation - 1.0f;
                        TempVal = -(1.0f / DiscriminatorActivation);
                        TempVal *= this.NeuralNetwork.ActivationFunctionDerivative(DiscriminatorRawOutput, 1);
                        TempVal *= DerivativeFeatureMaps[this.DerivativeFeatureMaps.Length - 1][Z][X][Y];


                        TempList1[Y] = TempVal;

                        Y++;
                    }

                    TempList2[X] = TempList1;

                    X++;
                }

                Outputs[Z] = TempList2;

                Z++;
            }

            return Outputs;
        }

        public void BackPropagateGenerator(double[] Inputs, double[] Outputs, bool PoolActivations, bool TrainWeights, int WeightOptimizerID, int FilterOptimizerID, bool ErrorOnly = false, int OutputNormalization = 9, bool NormalizeOutputLayer = true, bool TrainFilters = true, double DiscriminatorActivation = 0, double DiscriminatorRawActivation = 0)
        {
            int X = this.Filters.Length - 1;
            int Y = 0;
            int Z = 0;
            int ZZ = 0;
            int ZZZ = 0;
            int ZZZZ = 0;
            int A = 0;
            int B = 0;
            int C = 0;
            int D = 0;
            int E = 0;
            int I = 0;
            int J = 0;
            int K = 0;
            List<double> LocalActivations = new List<double>();
            List<double> PreviousActivations = new List<double>();
            List<double> PreviousErrors = new List<double>();
            List<double> LocalErrors = new List<double>();
            List<double> PreviousWeights = new List<double>();
            List<double> Filters = new List<double>();
            List<double> TempList = new List<double>();
            List<List<double>> TempList2 = new List<List<double>>();
            List<List<List<List<double>>>> Errors = new List<List<List<List<double>>>>();
            List<List<List<double>>> SubErrors = new List<List<List<double>>>();
            double[][][] BackpropErrors = new double[0][][];
            List<List<double>> SubSubErrors = new List<List<double>>();
            List<double> SubSubSubErrors = new List<double>();

            double[][][] FilterGradients = new double[0][][];
            double[][][] LocalGradients = new double[0][][];
            List<List<List<double>>> ErrorGradients = new List<List<List<double>>>();
            double[][][] NeuronGradients = new double[0][][];
            List<List<List<double>>> DerivativeGradients = new List<List<List<double>>>();
            List<List<List<double>>> PrevLayerGradients = new List<List<List<double>>>();
            List<List<List<double>>> SubFilters = new List<List<List<double>>>();
            List<List<List<double>>> SubFilters2 = new List<List<List<double>>>();
            List<List<double>> SubSubFilters = new List<List<double>>();
            List<double> SubSubSubFilters = new List<double>();
            Random Rnd = new Random();

            double Delta = 0;
            double NewDelta = 0;
            double ADAMDelta = 0;
            double SGDDelta = 0;
            double RMSPropDelta = 0;
            double TempVal1 = 0;
            double TempVal2 = 0;
            double TempVal3 = 0;
            int FunctionID = 0;
            double L2 = 0;
            int ZZZZMax = 0;
            //this.Errors = new List<List<List<List<double>>>>();

            this.FeedForwardGenerator((Inputs), PoolActivations, OutputNormalization, NormalizeOutputLayer);

            //InitializeNetwork();


            E = this.Filters.Length - 1;

            while (E >= 0)
            {
                if (E == this.Filters.Length - 1)
                {
                    //SubFilters = new List<List<List<double>>>();
                    //SubFilters.Add(this.ExpandVector(Outputs));



                    NeuronGradients = CalculateGeneratorLoss(DiscriminatorActivation,DiscriminatorRawActivation);

                    //NeuronGradients = ResolveAveragePooling(SubFilters, E);
                    //NeuronGradients = SubFilters;

                    //NeuronGradients = this.ElementWiseMultiply(NeuronGradients, this.DerivativeFeatureMaps[E]);
                    FilterGradients = this.Convolve(this.FeatureMaps[E - 1], NeuronGradients, 1, false);

                    BackpropErrors = this.DeConvolve(NeuronGradients, this.Filters[E - 1], 1, this.Filters[E][0].Length - 1);
                }
                else
                {                   
                    //NeuronGradients = ResolveAveragePooling(SubFilters, E);
                    //NeuronGradients = BackpropErrors;

                    if (E == 0)
                    {
                        LocalGradients = new double[1][][];
                        LocalGradients[0] = this.ExpandVector(this.NeuralNetwork.Activations[this.NeuralNetwork.Activations.Length - 1]);

                        NeuronGradients = this.ElementWiseMultiply(BackpropErrors, this.DerivativeFeatureMaps[E]);
                        FilterGradients = this.Convolve(ReshapeTensor(this.NeuralNetwork.Activations[this.NeuralNetwork.Activations.Length - 1], this.Filters[0].Length), NeuronGradients, 1, false);

                        NeuronGradients = this.PadLayerMaps(NeuronGradients, this.Filters[0][0].Length - 1);

                    }
                    else
                    {
                        NeuronGradients = this.ElementWiseMultiply(BackpropErrors, this.DerivativeFeatureMaps[E]);
                        FilterGradients = this.Convolve(this.FeatureMaps[E - 1], NeuronGradients, 1, false);

                        BackpropErrors = this.DeConvolve(NeuronGradients, this.Filters[E - 1], 1, this.Filters[E][0].Length - 1);
                    }

                }

                this.Errors[E] = (NeuronGradients);

                if (TrainFilters)
                {
                    X = 0;
                    while (X < this.Filters[E].Length)
                    {
                        Y = 0;
                        while (Y < this.Filters[E][X].Length)
                        {
                            Z = 0;
                            while (Z < this.Filters[E][X][Y].Length)
                            {
                                switch (FilterOptimizerID)
                                {
                                    case 0:
                                        SGDDelta = FilterGradients[X][Y][Z];

                                        //this.Filters[E][X][Y][Z] = this.Filters[E][X][Y][Z] - (SGDDelta + (0 * this.PrevDeltas[E][X][Y][Z]));

                                        this.CurrentDeltas[E][X][Y][Z] += FilterGradients[X][Y][Z];
                                        this.PrevDeltas[E][X][Y][Z] += FilterGradients[X][Y][Z];
                                        break;

                                    case 1:
                                        TempVal1 = (this.NeuralNetwork.RMSPropConst * this.PrevDeltas[E][X][Y][Z]) + (Math.Pow(FilterGradients[X][Y][Z], 2) * (1 - this.NeuralNetwork.RMSPropConst));
                                        this.PrevDeltas[E][X][Y][Z] = TempVal1;
                                        RMSPropDelta = this.LearningRate / (Math.Sqrt(TempVal1 + 0.00000000000000001)) * FilterGradients[X][Y][Z];
                                        //this.Filters[E][X][Y][Z] = this.Filters[E][X][Y][Z] - RMSPropDelta;

                                        this.CurrentDeltas[E][X][Y][Z] = RMSPropDelta;
                                        break;

                                    case 2:
                                        this.FiltersM[E][X][Y][Z] = (this.NeuralNetwork.B1 * this.FiltersM[E][X][Y][Z] + (1 - this.NeuralNetwork.B1) * FilterGradients[X][Y][Z]);
                                        this.FiltersV[E][X][Y][Z] = (this.NeuralNetwork.B2 * this.FiltersV[E][X][Y][Z] + (1 - this.NeuralNetwork.B2) * Math.Pow(FilterGradients[X][Y][Z], 2));
                                        ADAMDelta = (this.FiltersM[E][X][Y][Z] / (1 - this.NeuralNetwork.B1)) / Math.Sqrt((this.FiltersV[E][X][Y][Z] / (1 - this.NeuralNetwork.B2)) + 0.00000000000000001);
                                        this.CurrentDeltas[E][X][Y][Z] += ADAMDelta;
                                        //this.Filters[E][X][Y][Z] = this.Filters[E][X][Y][Z] - this.LearningRate * ADAMDelta;
                                        break;
                                }

                                Z++;
                            }

                            Y++;
                        }

                        X++;
                    }
                }

                //NormalizeFilters(E);


                E--;
            }

            //NeuronGradients = this.PoolMaps(this.Errors[0]);
            this.NeuralNetwork.BackPropagate((Inputs), this.Flatten3DVector((this.Errors[0])), OutputNormalization, TrainWeights, WeightOptimizerID, ErrorOnly, NormalizeOutputLayer, DiscriminatorActivation, DiscriminatorRawActivation);


            this.GlobalIterator++;
        }

        public double[][][] CreateEmptyLayerMaps(int MapDimensions, int MapCount, double InitVal)
        {
            int X = 0;
            double[][][] Outputs = new double[MapCount][][];

            while(X < MapCount)
            {
                Outputs[X] = CreateEmptyMap(MapDimensions,InitVal);

                X++;
            }

            return Outputs;
        }

        public List<List<List<double>>> ResolveAveragePooling(List<List<List<double>>> InputLayer,int LayerID)
        {
            List<List<List<double>>> RetVal = new List<List<List<double>>>();
            List<List<double>> TempMap = new List<List<double>>();
            int X = 0;
            int Y = 0;
            int Z = 0;
            int A = 0;
            int B = 0;
            double GradientVal = 0;

            while (X < InputLayer.Count)
            {
                //TempMap = this.CreateEmptyMap(this.DerivativeFeatureMaps[(LayerID)][0].Length);
                Y = 0;
                while(Y < InputLayer[X].Count)
                {
                    Z = 0;
                    while(Z < InputLayer[X][Y].Count)
                    {
                        A = 0;
                        while(A < this.PoolingSchedule[LayerID])
                        {
                            B = 0;
                            while(B < this.PoolingSchedule[LayerID])
                            {
                                if(Y * this.PoolingSchedule[LayerID] + A < TempMap.Count && Z * this.PoolingSchedule[LayerID] + B < TempMap.Count)
                                {
                                    TempMap[Y * this.PoolingSchedule[LayerID] + A][Z * this.PoolingSchedule[LayerID] + B] = InputLayer[X][Y][Z];
                                }
                                

                                B++;
                            }

                            A++;
                        }


                        Z++;
                    }

                    Y++;
                }

                RetVal.Add(TempMap);

                X++;
            }

            return RetVal;
        }

        public void BackPropagate(double[][] Inputs, double[] Outputs, bool PoolActivations, bool TrainWeights, int WeightOptimizerID, int FilterOptimizerID, bool ErrorOnly = false, int OutputNormalization = 9, bool NormalizeOutputLayer = true, bool TrainFilters = true, double DiscriminatorActivation = 0, double DiscriminatorRawActivation = 0)
        {
            int X = this.Filters.Length - 1;
            int Y = 0;
            int Z = 0;
            int ZZ = 0;
            int ZZZ = 0;
            int ZZZZ = 0;
            int A = 0;
            int B = 0;
            int C = 0;
            int D = 0;
            int E = 0;
            int I = 0;
            int J = 0;
            int K = 0;
            List<double> LocalActivations = new List<double>();
            List<double> PreviousActivations = new List<double>();
            List<double> PreviousErrors = new List<double>();
            List<double> LocalErrors = new List<double>();
            List<double> PreviousWeights = new List<double>();
            List<double> Filters = new List<double>();
            List<double> TempList = new List<double>();
            List<List<double>> TempList2 = new List<List<double>>();
            List<List<List<List<double>>>> Errors = new List<List<List<List<double>>>>();
            List<List<List<double>>> SubErrors = new List<List<List<double>>>();
            double[][][] BackpropErrors = new double[0][][];
            List<List<double>> SubSubErrors = new List<List<double>>();
            List<double> SubSubSubErrors = new List<double>();

            double[][][] FilterGradients = new double[0][][];
            double[][][] LocalGradients = new double[0][][];
            List<List<List<double>>> ErrorGradients = new List<List<List<double>>>();
            double[][][] NeuronGradients = new double[0][][];
            List<List<List<double>>> DerivativeGradients = new List<List<List<double>>>();
            List<List<List<double>>> PrevLayerGradients = new List<List<List<double>>>();
            double[][][] SubFilters = new double[0][][];
            List<List<List<double>>> SubFilters2 = new List<List<List<double>>>();
            List<List<double>> SubSubFilters = new List<List<double>>();
            List<double> SubSubSubFilters = new List<double>();
            Random Rnd = new Random();

            double Delta = 0;
            double NewDelta = 0;
            double ADAMDelta = 0;
            double SGDDelta = 0;
            double RMSPropDelta = 0;
            double TempVal1 = 0;
            double TempVal2 = 0;
            double TempVal3 = 0;
            int FunctionID = 0;
            double L2 = 0;
            int ZZZZMax = 0;
            //this.Errors = new List<List<List<List<double>>>>();

            this.FeedForward(Inputs, PoolActivations, OutputNormalization, NormalizeOutputLayer);

            //InitializeNetwork();

            this.NeuralNetwork.BackPropagate(this.Flatten3DVector(this.FeatureMaps[this.FeatureMaps.Length - 1]), Outputs, OutputNormalization, TrainWeights, WeightOptimizerID, ErrorOnly, NormalizeOutputLayer, DiscriminatorActivation, DiscriminatorRawActivation);

            E = this.Filters.Length - 1;

            while (E >= 0)
            {
                if (E == this.Filters.Length - 1)
                {
                    SubFilters = ReshapeTensor(this.NeuralNetwork.Errors[0], this.FeatureMaps[E].Length);

                    //NeuronGradients = ResolveAveragePooling(SubFilters, E);
                    NeuronGradients = SubFilters;
                    NeuronGradients = this.ElementWiseMultiply(NeuronGradients, this.DerivativeFeatureMaps[E]);
                    FilterGradients = this.Convolve(this.FeatureMaps[E - 1], NeuronGradients, 1, false);
                  
                    BackpropErrors = this.DeConvolve(NeuronGradients, this.Filters[E-1], 1, this.Filters[E][0].Length - 1 );
                    
                    
                }
                else
                {
                    //NeuronGradients = ResolveAveragePooling(SubFilters, E);
                    //NeuronGradients = BackpropErrors;

                    //SubFilters = this.ElementWiseMultiply(SubFilters, this.MaxPoolGradients[E]);
                    if (E == 0)
                    {
                        LocalGradients = new double[1][][];
                        LocalGradients[0] = Inputs;

                        NeuronGradients = this.ElementWiseMultiply(BackpropErrors, this.DerivativeFeatureMaps[E]);
                        FilterGradients = this.Convolve(LocalGradients, NeuronGradients, 1, false);
                        //NeuronGradients = this.DeConvolve(NeuronGradients, this.Filters[E], 1, this.Filters[E][0].Count - 1);                       
                    }
                    else
                    {
                        NeuronGradients = this.ElementWiseMultiply(NeuronGradients, this.DerivativeFeatureMaps[E]);
                        FilterGradients = this.Convolve(this.FeatureMaps[E - 1], NeuronGradients, 1, false);
                        BackpropErrors = this.DeConvolve(NeuronGradients, this.Filters[E-1], 1, this.Filters[E][0].Length - 1);


                        //Remember to switch back
                        
                    }

                }

                this.Errors[E] = (NeuronGradients);

                if (TrainFilters)
                {
                    X = 0;
                    while (X < this.Filters[E].Length)
                    {
                        Y = 0;
                        while (Y < this.Filters[E][X].Length)
                        {
                            Z = 0;
                            while (Z < this.Filters[E][X][Y].Length)
                            {
                                switch (FilterOptimizerID)
                                {
                                    case 0:
                                        SGDDelta = FilterGradients[X][Y][Z];

                                        //this.Filters[E][X][Y][Z] = this.Filters[E][X][Y][Z] - (SGDDelta + (0 * this.PrevDeltas[E][X][Y][Z]));

                                        this.CurrentDeltas[E][X][Y][Z] += FilterGradients[X][Y][Z];
                                        this.PrevDeltas[E][X][Y][Z] += FilterGradients[X][Y][Z];
                                        break;

                                    case 1:
                                        TempVal1 = (this.NeuralNetwork.RMSPropConst * this.PrevDeltas[E][X][Y][Z]) + (Math.Pow(FilterGradients[X][Y][Z], 2) * (1 - this.NeuralNetwork.RMSPropConst));
                                        this.PrevDeltas[E][X][Y][Z] = TempVal1;
                                        RMSPropDelta = this.LearningRate / (Math.Sqrt(TempVal1 + 0.00000000000000001)) * FilterGradients[X][Y][Z];
                                        //this.Filters[E][X][Y][Z] = this.Filters[E][X][Y][Z] - RMSPropDelta;

                                        this.CurrentDeltas[E][X][Y][Z] = RMSPropDelta;
                                        break;

                                    case 2:
                                        this.FiltersM[E][X][Y][Z] = (this.NeuralNetwork.B1 * this.FiltersM[E][X][Y][Z] + (1 - this.NeuralNetwork.B1) * FilterGradients[X][Y][Z]);
                                        this.FiltersV[E][X][Y][Z] = (this.NeuralNetwork.B2 * this.FiltersV[E][X][Y][Z] + (1 - this.NeuralNetwork.B2) * Math.Pow(FilterGradients[X][Y][Z], 2));
                                        ADAMDelta = (this.FiltersM[E][X][Y][Z] / (1 - this.NeuralNetwork.B1)) / Math.Sqrt((this.FiltersV[E][X][Y][Z] / (1 - this.NeuralNetwork.B2)) + 0.00000000000000001);
                                        this.CurrentDeltas[E][X][Y][Z] += ADAMDelta;
                                        //this.Filters[E][X][Y][Z] = this.Filters[E][X][Y][Z] - this.LearningRate * ADAMDelta;
                                        break;
                                }

                                Z++;
                            }

                            Y++;
                        }

                        X++;
                    }
                }

                //NormalizeFilters(E);


                E--;
            }

            this.GlobalIterator++;
        }

        public void ApplyGradients(int BatchSize)
        {
            int X = 0;
            int Y = 0;
            int Z = 0;
            int ZZ = 0;

            while(X < this.Filters.Length)
            {
                Y = 0;
                while(Y < this.Filters[X].Length)
                {
                    Z = 0;
                    while(Z < this.Filters[X][Y].Length)
                    {
                        ZZ = 0;
                        while(ZZ < this.Filters[X][Y][Z].Length)
                        {
                            this.Filters[X][Y][Z][ZZ] = this.Filters[X][Y][Z][ZZ] - ((this.CurrentDeltas[X][Y][Z][ZZ]/BatchSize) * this.NeuralNetwork.LearningRate);
                            this.CurrentDeltas[X][Y][Z][ZZ] = 0;

                            ZZ++;
                        }

                        Z++;
                    }

                    Y++;
                }

                X++;
            }

            //ResetStoredAdamValues();
        }

        public List<List<List<double>>> UpscaleGradients(List<List<List<double>>> Input,int DesiredDims,int KernelSize)
        {
            int X = 0;
            List<List<List<double>>> RetVal = new List<List<List<double>>>();

            while (X < Input.Count)
            {
                RetVal.Add(KNearestNeighborUpscale(Input[X],DesiredDims,KernelSize));

                X++;
            }

            return RetVal;
        }

        public List<List<double>> KNearestNeighborUpscale(List<List<double>> Input,int DestinationDims,int KernelSize)
        {
            List<List<double>> RetVal = new List<List<double>>();
            List<double> TempRow = new List<double>();
            int X = 0;
            int Y = 0;
            int A = 0;
            int B = 0;
            double TempVal = 0;

            while(X < DestinationDims)
            {
                TempRow = new List<double>();
                Y = 0;
                while(Y < DestinationDims)
                {
                    TempRow.Add(0);

                    Y++;
                }

                RetVal.Add(TempRow);

                X++;
            }


            X = 0;
            while(X < Input.Count - KernelSize)
            {
                Y = 0;
                while(Y < Input[X].Count - KernelSize)
                {
                    TempVal = Input[X][Y];
                    //RetVal[X][Y] = TempVal;
                    A = 0;
                    while(A < KernelSize)
                    {
                        B = 0;
                        while (B < KernelSize)
                        {
                            RetVal[(X*KernelSize) + A][(Y*KernelSize) + B] = TempVal;

                            B++;
                        }

                        A++;
                    }

                    Y++;
                }

                X++;
            }

            return RetVal;
        }

        public double CalculateStandardDeviation(List<List<double>> Inputs, double Mean = 0.0f)
        {
            double Variance = 0;
            int X = 0;
            int Y = 0;
            int Z = 0;
            int Counter = 0;

            if (Mean == 0)
            {
                while (X < Inputs.Count)
                {
                    Y = 0;
                    while (Y < Inputs[X].Count)
                    {
                        Mean += Inputs[X][Y];
                        Counter++;

                        Y++;
                    }

                    X++;
                }

                Mean /= Counter;
            }

            X = 0;
            while (X < Inputs.Count)
            {
                Y = 0;
                while (Y < Inputs[X].Count)
                {
                    Variance += Math.Pow(Inputs[X][Y] - Mean, 2);

                    Y++;
                }

                X++;
            }

            Variance /= (Inputs.Count * Inputs[0].Count);

            return Math.Sqrt(Variance);
        }

        public double CalculateStandardDeviation(List<List<List<double>>> Inputs, double Mean = 0.0f)
        {
            double Variance = 0;
            int X = 0;
            int Y = 0;
            int Z = 0;

            if (Mean == 0)
            {
                while (X < Inputs.Count)
                {
                    Y = 0;
                    while(Y < Inputs[X].Count)
                    {
                        Z = 0;
                        while(Z < Inputs[X][Y].Count)
                        {
                            Mean += Inputs[X][Y][Z];

                            Z++;
                        }

                        Y++;
                    }                    

                    X++;
                }

                Mean /= (Inputs.Count * (Inputs[0].Count * Inputs[0][0].Count));
            }

            X = 0;
            while (X < Inputs.Count)
            {
                Y = 0;
                while (Y < Inputs[X].Count)
                {
                    Z = 0;
                    while (Z < Inputs[X][Y].Count)
                    {
                        Variance += Math.Pow(Inputs[X][Y][Z]-Mean,2);

                        Z++;
                    }

                    Y++;
                }

                X++;
            }           

            Variance /= (Inputs.Count * (Inputs[0].Count * Inputs[0][0].Count));

            return Math.Sqrt(Variance);
        }

        public double ZScore(List<List<List<double>>> Inputs, double SamplePoint, double Mean = 0.0f)
        {
            int X = 0;
            int Y = 0;
            int Z = 0;

            if (Mean == 0)
            {
                while (X < Inputs.Count)
                {
                    Y = 0;
                    while(Y < Inputs[X].Count)
                    {
                        Z = 0;
                        while(Z < Inputs[X][Y].Count)
                        {
                            Mean += Inputs[X][Y][Z];

                            Z++;
                        }

                        Y++;
                    }                    

                    X++;
                }

                Mean /= (Inputs.Count * (Inputs[0].Count * Inputs[0][0].Count));
            }

            return (SamplePoint - Mean) / CalculateStandardDeviation(Inputs);
        }

        public List<List<double>> NormalizeDataSet(List<List<double>> Inputs, int NormalizationType = 4)
        {
            int X = 0;
            int Y = 0;
            int Z = 0;
            double Mean = 0;
            double StdDev = 0;

            while (X < Inputs.Count)
            {
                Y = 0;
                while (Y < Inputs[X].Count)
                {
                    Mean += Inputs[X][Y];

                    Y++;
                }

                X++;
            }

            Mean /= (Inputs.Count * (Inputs[0].Count * Inputs[0].Count));
            StdDev = CalculateStandardDeviation(Inputs, Mean);

            this.FilterMean = Mean;
            this.FilterVariance = StdDev;

            X = 0;
            while (X < Inputs.Count)
            {
                Y = 0;
                while (Y < Inputs[X].Count)
                {
                    Inputs[X][Y] = (Inputs[X][Y] - Mean) / Math.Sqrt(StdDev);

                    Y++;
                }

                X++;
            }

            return Inputs;
        }

        public List<List<List<double>>> NormalizeDataSet(List<List<List<double>>> Inputs,int NormalizationType = 4)
        {
            int X = 0;
            int Y = 0;
            int Z = 0;
            double Mean = 0;
            double StdDev = 0;
            int Counter = 0;
            double MaxVal = Inputs[0][0][0];
            double MinVal = Inputs[0][0][0];

            while(X < Inputs.Count)
            {
                Y = 0;
                while(Y < Inputs[X].Count)
                {
                    Z = 0;
                    while(Z < Inputs[X][Y].Count)
                    {
                        Mean += Inputs[X][Y][Z];

                        if (Inputs[X][Y][Z] > MaxVal)
                        {
                            MaxVal = Inputs[X][Y][Z];
                        }

                        if (Inputs[X][Y][Z] < MinVal)
                        {
                            MinVal = Inputs[X][Y][Z];
                        }

                        Counter++;

                        Z++;
                    }

                    Y++;
                }

                X++;
            }

            Mean /= Counter;
            StdDev = CalculateStandardDeviation(Inputs, Mean);

            this.FilterMean = Mean;
            this.FilterVariance = StdDev;

            X = 0;
            while (X < Inputs.Count)
            {
                Y = 0;
                while (Y < Inputs[X].Count)
                {
                    Z = 0;
                    while (Z < Inputs[X][Y].Count)
                    {
                        switch(NormalizationType)
                        {
                            case 0:
                                Inputs[X][Y][Z] = Math.Tanh(Inputs[X][Y][Z]);
                                break;
                            case 3:
                                Inputs[X][Y][Z] = (Inputs[X][Y][Z] - MinVal) / (MaxVal - MinVal);
                                break;
                            case 4:
                                Inputs[X][Y][Z] = (Inputs[X][Y][Z] - Mean) / (StdDev);
                                break;
                        }
                        

                        Z++;
                    }

                    Y++;
                }

                X++;
            }

            return Inputs;
        }

        public List<List<List<double>>> AvgValues(List<List<List<double>>> Inputs,int Iterations)
        {
            int X = 0;
            int Y = 0;
            int Z = 0;

            while(X < Inputs.Count)
            {
                Y = 0;
                while(Y < Inputs[X].Count)
                {
                    Z = 0;
                    while(Z < Inputs[X][Y].Count)
                    {
                        Inputs[X][Y][Z] /= Iterations;

                        Z++;
                    }

                    Y++;
                }

                X++;
            }

            return Inputs;
        }

        public List<List<double>> CopyFeatures(List<List<double>> Input)
        {
            int X = 0;
            int Y = 0;
            int Z = 0;
            List<List<double>> TempList2 = new List<List<double>>();
            List<double> TempList = new List<double>();

            while(X < Input.Count)
            {
                TempList = new List<double>();
                Y = 0;
                while(Y < Input[X].Count)
                {
                    TempList.Add((double)Input[X][Y]);

                    Y++;
                }

                TempList2.Add(TempList);

                X++;
            }

            return TempList2;
        }

        public List<List<List<double>>> PoolGradients(List<List<List<double>>> Input, List<List<List<double>>> Filters, int KernelSize)
        {
            int X = 0;
            int Y = 0;
            int Z = 0;
            int A = 0;
            int B = 0;
            int Counter = 0;
            int XPooling = (int)Math.Max(1,(Input.Count / Filters.Count));
            int YPooling = (int)Math.Max(1,Input[0].Count / Filters[0].Count);
            int ZPooling = (int)(Math.Max(1,Input[0][0].Count / Filters[0][0].Count));
            List<List<List<double>>> RetVal = new List<List<List<double>>>();
            List<List<List<double>>> TempList4 = new List<List<List<double>>>();
            List<List<double>> TempList3 = new List<List<double>>();
            List<List<double>> TempList2 = new List<List<double>>();
            List<double> TempList = new List<double>();
            double TempVal = 0;

            if(Filters.Count > Input.Count || Filters[0].Count > Input[0].Count || Filters[0][0].Count > Input[0][0].Count)
            {
                return Input;
            }

            X = 0;
            while(X < Input.Count)
            {
                TempList2 = this.CopyFeatures(Input[X]);
                Y = 0;
                while(Y < Input[X].Count)
                {
                    Z = 0;
                    while(Z < Input[X][Y].Count)
                    {
                        TempVal = Math.Abs(Input[X][Y][Z]);
                        A = 1;
                        while(A < XPooling)
                        {
                            if (Math.Abs(Input[X + A][Y][Z]) > Math.Abs(TempVal))
                            {
                                //TempVal = Input[X + A][Y][Z];
                            }

                            TempVal += Input[X + A][Y][Z];

                            A++;
                        }

                        //TempVal /= XPooling;

                        TempList2[Y][Z] = TempVal;

                        Z++;
                    }

                    Y++;
                }

                RetVal.Add(TempList2);

                X+=XPooling;
            }


            X = 0;
            while(X < RetVal.Count)
            {
                TempList3 = new List<List<double>>();
                //Pool along Y/Z
                Y = 0;
                while (Y < RetVal[X].Count)
                {
                    TempList = new List<double>();
                    Z = 0;
                    while (Z < RetVal[X][Y].Count)
                    {

                        Counter = 0;
                        TempVal = Math.Abs(RetVal[X][Y][Z]);
                        A = 0;
                        while (A < YPooling)
                        {
                            B = 0;
                            while (B < ZPooling)
                            {
                                if (Y + A < RetVal[X].Count && Z + B < RetVal[X][Y].Count)
                                {
                                    if (Math.Abs(RetVal[X][Y + A][Z + B]) > Math.Abs(TempVal))
                                    {
                                        //TempVal = RetVal[X][Y + A][Z + B];
                                    }
                                    TempVal += TempList2[Y + A][Z + B];
                                    Counter++;
                                }

                                B++;
                            }

                            A++;
                        }

                        //TempVal /= Counter;

                        TempList.Add(TempVal);

                        Z += ZPooling;
                    }

                    TempList3.Add(TempList);

                    Y += YPooling;
                }

                TempList4.Add(TempList3);

                X++;
            }
            


            return TempList4;
        }

        public List<List<List<double>>> MaxGradients(List<List<List<double>>> Input,List<List<List<double>>> Filters, int KernelSize,int LayerID)
        {
            int X = 0;
            int Y = 0;
            int Z = 0;
            int A = 0;
            int B = 0;
            int C = 0;
            double MaxVal = 0;
            double AvgVal = 0;
            List<List<double>> RetVal = new List<List<double>>();
            List<double> TempVals = new List<double>();
            List<List<List<double>>> FinalRetVal = new List<List<List<double>>>();
            List<List<List<double>>> Input2 = new List<List<List<double>>>();
            int XPooling = (int)(Input.Count/ Filters.Count);
            int YPooling = (int)(Input[0].Count / Filters[0].Count);
            int ZPooling = (int)(Input[0][0].Count / Filters[0][0].Count);

            while(X < Input.Count)
            {
                Input[X] = this.PoolFeature(Input[X], KernelSize);

                X++;
            }

            X = 0;
            while(X < Filters.Count)
            {
                FinalRetVal.Add(Input[X]);

                X++;
            }

            return FinalRetVal;
        }

        public List<List<double>> PoolFeature(List<List<double>> Input, int KernelSize)
        {
            int X = 0;
            int Y = 0;
            int Z = 0;
            int A = 0;
            int B = 0;
            double MaxVal = 0;
            double AvgVal = 0;
            List<List<double>> RetVal = new List<List<double>>();
            List<double> TempVals = new List<double>();
            List<List<List<double>>> FinalRetVal = new List<List<List<double>>>();

            RetVal = this.CopyFeatures(Input);

            X = 0;
            while (X < Input.Count)
            {
                TempVals = new List<double>();
                Y = 0;
                while (Y < Input[X].Count)
                {
                    AvgVal = 0;
                    MaxVal = Input[X][Y];
                    A = 0;
                    while (A < KernelSize)
                    {
                        B = 0;
                        while (B < KernelSize)
                        {
                            if (A + X < Input.Count && B + Y < Input[X].Count)
                            {
                                if (Math.Abs(Input[X + A][Y + B]) > Math.Abs(MaxVal))
                                {
                                    MaxVal = Input[X + A][Y + B];
                                }
                            }


                            B++;
                        }

                        A++;
                    }

                    A = 0;
                    while(A < KernelSize)
                    {
                        B = 0;
                        while (B < KernelSize)
                        {
                            if (A + X < Input.Count && B + Y < Input[X].Count)
                            {
                                if (Input[X + A][Y + B] == MaxVal)
                                {
                                    RetVal[X + A][Y+B] =(MaxVal);
                                }
                                else
                                {
                                    RetVal[X + A][Y+B] =(0);
                                }
                            }

                            B++;
                        }
                        A++;
                    }

                    Y += KernelSize;
                }

                

                X += KernelSize;
            }

            return RetVal;
        }

        public double[][][] PoolLayer(double[][][] Input,int LayerID,int KernelSize,bool AvgLayer)
        {
            int X = 0;
            int Y = 0;
            int Z = 0;
            int A = 0;
            int B = 0;
            double MaxVal = 0;
            double AvgVal = 0;
            double TempVal = 0;
            int Counter = 0;
            double[][] RetVal;
            double[] TempVals;
            double[][][] FinalRetVal;
            double[] MaxList1;
            double[][] MaxList2;
            int YLimit = 0;
            int ZLimit = 0;

            FinalRetVal = new double[Input.Length][][];

            Z = 0;
            while (Z < Input.Length)
            {
                MaxList2 = new double[(Input[Z].Length - KernelSize + 1)][];
                RetVal = new double[(Input[Z].Length - KernelSize + 1)][];
                X = 0;
                while (X < (Input[Z].Length-KernelSize+1))
                {
                    TempVals = new double[(Input[Z][X].Length - KernelSize + 1)];
                    MaxList1 = new double[(Input[Z][X].Length - KernelSize + 1)];
                    Y = 0;
                    while (Y < (Input[Z][X].Length-KernelSize+1))
                    {
                        AvgVal = 0;
                        Counter = 0;
                        MaxVal = Input[Z][X][Y];
                        A = 0;
                        while (A < KernelSize)
                        {
                            B = 0;
                            while (B < KernelSize)
                            {
                                if (A + X < Input[Z].Length && B + Y < Input[Z][X+A].Length)
                                {
                                    AvgVal += Input[Z][X + A][Y + B];

                                    if (Input[Z][X + A][Y + B] > MaxVal)
                                    {
                                        MaxVal = Input[Z][X + A][Y + B];
                                    }

                                    Counter++;
                                }
                                else
                                {
                                    break;
                                }


                                B++;
                            }

                            A++;
                        }
                        
                        A = 0;
                        while (A < KernelSize)
                        {
                            B = 0;
                            while (B < KernelSize)
                            {
                                if (A + X < this.MaxPoolGradients[LayerID][Z][0].Length && B + Y < this.MaxPoolGradients[LayerID][Z][0].Length)
                                {
                                    if (Input[Z][X + A][Y + B] == MaxVal)
                                    {
                                        this.MaxPoolGradients[LayerID][Z][X + A][Y + B] = 1;
                                        
                                    }
                                    else
                                    {
                                        this.MaxPoolGradients[LayerID][Z][X + A][Y + B] = 0;
                                    }
                                }
                                else
                                {
                                    break;
                                }


                                B++;
                            }

                            A++;
                        }

                        AvgVal /= (Counter);

                        if (AvgLayer)
                        {
                            TempVals[Y] = AvgVal;
                        }
                        else
                        {
                            TempVals[Y] = MaxVal;
                        }

                        Y+=KernelSize;
                    }

                    RetVal[X] = TempVals;

                    X+=KernelSize;
                }

                FinalRetVal[Z] = RetVal;

                Z++;
            }

            return FinalRetVal;
        }

        public double[][][] ActivateConvolutions(double[][][] Input,int ActivationID)
        {
            int X = 0;
            int Y = 0;
            int Z = 0;
            double[][][] Output = new double[Input.Length][][];
            double[][] TempList2;
            double[] TempList;

            while (X < Input.Length)
            {
                TempList2 = new double[Input[X].Length][];
                Y = 0;
                while (Y < Input[X].Length)
                {
                    TempList = new double[Input[X][Y].Length];
                    Z = 0;
                    while (Z < Input[X][Y].Length)
                    {
                        switch (ActivationID)
                        {
                            case 0:
                                TempList[Z] = this.NeuralNetwork.ActivationFunction(Input[X][Y][Z], 0);
                                break;

                            case 1:
                                TempList[Z] = this.NeuralNetwork.ActivationFunction(Input[X][Y][Z], 1);
                                break;

                            case 2:
                                TempList[Z] = this.NeuralNetwork.ActivationFunction(Input[X][Y][Z], 2);
                                break;
                            case 3:
                                TempList[Z] = this.NeuralNetwork.ActivationFunction(Input[X][Y][Z], 3);
                                break;
                        }

                        Z++;
                    }

                    TempList2[Y] = TempList;

                    Y++;
                }

                Output[X] = TempList2;

                X++;
            }


            return Output;
        }

        //public List<List<List<double>>>

        public double[][][] ActivateDerivativeConvolutions(double[][][] Input, int ActivationID)
        {
            int X = 0;
            int Y = 0;
            int Z = 0;
            double[][][] Output = new double[Input.Length][][];
            double[][] TempList2;
            double[] TempList;

            while (X < Input.Length)
            {
                TempList2 = new double[Input[X].Length][];
                Y = 0;
                while (Y < Input[X].Length)
                {
                    TempList = new double[Input[X][Y].Length];
                    Z = 0;
                    while (Z < Input[X][Y].Length)
                    {
                        switch (ActivationID)
                        {
                            case 0:
                                TempList[Z] = this.NeuralNetwork.ActivationFunctionDerivative(Input[X][Y][Z], 0);
                                break;

                            case 1:
                                TempList[Z] = this.NeuralNetwork.ActivationFunctionDerivative(Input[X][Y][Z], 1);
                                break;

                            case 2:
                                TempList[Z] = this.NeuralNetwork.ActivationFunctionDerivative(Input[X][Y][Z], 2);
                                break;
                            case 3:
                                TempList[Z] = this.NeuralNetwork.ActivationFunctionDerivative(Input[X][Y][Z], 3);
                                break;
                        }

                        Z++;
                    }

                    TempList2[Y] = TempList;

                    Y++;
                }

                Output[X] = TempList2;

                X++;
            }


            return Output;
        }


        public double[][][] Convolve(double[][][] Features,double[][][] FilterList, int Stride, bool RotateFilters)
        {
            int X = 0;
            int Y = 0;
            int Z = 0;
            int ZZ = 0;
            int A = 0;
            int B = 0;
            int C = 0;
            int D = 0;
            double TempVal = 0;
            double TempVal2 = 0;
            double[] TempList;
            double[][] TempList2;
            double[][] SummedMap;
            double[][][] TempList3 = new double[FilterList.Length][][];
            double[][][] RotatedFilterList = new double[FilterList.Length][][];
            int Counter = 0;

            if(RotateFilters)
            {
                X = 0;
                while (X < FilterList.Length)
                {
                    RotatedFilterList[X] = this.Rotate2DMatrix180(FilterList[X]);

                    X++;
                }
            }
            else
            {
                RotatedFilterList = FilterList;
            }
            

            X = 0;
            while (X < RotatedFilterList.Length)
            {
                SummedMap = new double[Features[0].Length - (RotatedFilterList[X].Length) + 1][];
                Y = 0;
                while (Y < Features.Length)
                {
                    TempList2 = new double[Features[Y].Length - (RotatedFilterList[X].Length) + 1][];
                    C = 0;
                    while (C < Features[Y].Length - (RotatedFilterList[X].Length) + 1)
                    {
                        TempList = new double[Features[Y][C].Length - (RotatedFilterList[X].Length) + 1];
                        D = 0;
                        while (D < Features[Y][C].Length - (RotatedFilterList[X].Length) + 1)
                        {
                            Counter = 0;
                            TempVal = 0;
                            A = 0;
                            while (A < RotatedFilterList[X].Length)
                            {
                                B = 0;
                                while (B < RotatedFilterList[X][A].Length)
                                {

                                    TempVal2 = (RotatedFilterList[X][A][B] * Features[Y][C + A][D + B]);

                                    Counter++;
                                    TempVal += TempVal2;



                                    B++;
                                }

                                A++;
                            }

                            //TempVal = Math.Tanh(TempVal);

                            TempList[D] = TempVal;

                            D+=Stride;
                        }

                        TempList2[C] = TempList;

                        C+=Stride;
                    }

                    if(Y == 0)
                    {
                        SummedMap = TempList2;
                    }
                    else
                    {
                        SummedMap = this.ElementWiseSummation(TempList2, SummedMap);
                    }
                    

                    Y++;
                }

                TempList3[X] = SummedMap;

                X++;
            }

            return TempList3;
        }

        public double[][][] FullConvolve(double[][][] Features, double[][][] FilterList, int Stride, bool RotateFilters)
        {
            int X = 0;
            int Y = 0;
            int Z = 0;
            int ZZ = 0;
            int A = 0;
            int B = 0;
            int C = 0;
            int D = 0;
            double TempVal = 0;
            double TempVal2 = 0;
            double[] TempList;
            double[][] TempList2;
            double[][] SummedMap;
            double[][][] TempList3 = new double[Features.Length][][];
            double[][][] RotatedFilterList = new double[FilterList.Length][][];
            int Counter = 0;

            if (RotateFilters)
            {
                X = 0;
                while (X < FilterList.Length)
                {
                    RotatedFilterList[X] = this.Rotate2DMatrix180(FilterList[X]);

                    X++;
                }
            }
            else
            {
                RotatedFilterList = FilterList;
            }


            X = 0;
            while (X < RotatedFilterList.Length)
            {
                SummedMap = new double[Features[0].Length][];
                Y = 0;
                while (Y < Features.Length)
                {
                    TempList2 = new double[Features[Y].Length][];
                    C = 0;
                    while (C < Features[Y].Length)
                    {
                        TempList = new double[Features[Y][C].Length];
                        D = 0;
                        while (D < Features[Y][C].Length)
                        {
                            Counter = 0;
                            TempVal = 0;
                            A = 0;
                            while (A < RotatedFilterList[X].Length)
                            {
                                B = 0;
                                while (B < RotatedFilterList[X][A].Length)
                                {

                                    TempVal2 = (RotatedFilterList[X][A][B] * Features[Y][C + A][D + B]);

                                    Counter++;
                                    TempVal += TempVal2;



                                    B++;
                                }

                                A++;
                            }

                            //TempVal = Math.Tanh(TempVal);

                            TempList[D] = TempVal;

                            D += Stride;
                        }

                        TempList2[C] = TempList;

                        C += Stride;
                    }

                    if (Y == 0)
                    {
                        SummedMap = TempList2;
                    }
                    else
                    {
                        SummedMap = this.ElementWiseSummation(TempList2, SummedMap);
                    }


                    Y++;
                }

                TempList3[X] = SummedMap;

                X++;
            }

            return TempList3;
        }
        public double ELU(double Input)
        {
            if(Input >= 0)
            {
                return Input;
            }
            else
            {
                return Math.Pow(Math.E, Input - 1);
            }
        }


        public double[][][] DeConvolve(double[][][] Features, double[][][] FilterList, int Stride,int Padding)
        {
            int X = 0;
            int Y = 0;
            int Z = 0;
            int ZZ = 0;
            int A = 0;
            int B = 0;
            int C = 0;
            int D = 0;
            int E = 0;
            int F = 0;
            int U = 0;
            int V = 0;
            double TempVal = 0;
            double TempVal2 = 0;
            double[] TempList;
            double[][] TempList2;
            double[][] SummedMap;
            double[][][] TempList3 = new double[FilterList.Length][][];
            double[][][] RotatedFilterList = new double[FilterList.Length][][];
            int Counter = 0;

            X = 0;
            while (X < FilterList.Length)
            {
                RotatedFilterList[X] = this.Rotate2DMatrix180(FilterList[X]);

                X++;
            }

            U = 0;
            while(U < FilterList.Length)
            {
                SummedMap = new double[Features.Length][];

                V = 0;
                while(V < Features.Length)
                {
                    TempList2 = new double[0][];
                    TempList2 = CreateEmptyMap(Features[V].Length + Padding);
                    X = 0;
                    while (X < Features[V].Length - FilterList[U].Length + 1)
                    {
                        Y = 0;
                        while (Y < Features[V][0].Length - FilterList[U][0].Length + 1)
                        {
                            A = 0;
                            while (A < FilterList[U].Length)
                            {
                                B = 0;
                                while (B < FilterList[U][A].Length)
                                {
                                    TempList2[X + A][Y + B] += (Features[V][X][Y] * FilterList[U][A][B]);

                                    B++;
                                }

                                A++;
                            }

                            Y++;
                        }

                        X++;
                    }

                    if (V == 0)
                    {
                        SummedMap = TempList2;
                    }
                    else
                    {
                        SummedMap = this.ElementWiseSummation(TempList2, SummedMap);
                    }

                    V++;
                }

                TempList3[U] = SummedMap;

                U++;
            }


            return TempList3;
        }

        public double[][] CreateEmptyMap(int Dimensions,double InitializationVal = 0)
        {
            double[] SubOutput = new double[Dimensions];
            double[][] Output = new double[Dimensions][];
            int X = 0;
            int Y = 0;

            while(X < Dimensions)
            {
                SubOutput = new double[Dimensions];
                Y = 0;
                while(Y < Dimensions)
                {
                    SubOutput[Y] = InitializationVal;

                    Y++;
                }

                Output[X] = SubOutput;

                X++;
            }

            return Output;
        }




        public List<List<List<double>>> PoolMaps(List<List<List<double>>> Activations, int KernelSize = 2)
        {
            List<List<List<double>>> RetVal = new List<List<List<double>>>();
            List<List<double>> TempList2 = new List<List<double>>();
            List<double> TempList = new List<double>();
            int X = 0;
            int Y = 0;
            int Z = 0;
            int A = 0;
            int B = 0;
            int C = 0;
            double MaxVal = Activations[0][0][0];
            double AvgVal = 0;

            while(X < Activations.Count)
            {
                TempList2 = new List<List<double>>();
                AvgVal = 0;
                Y = 0;
                while( Y < Activations[X].Count - KernelSize)
                {
                    TempList = new List<double>();
                    Z = 0;
                    while(Z < Activations[X][Y].Count - KernelSize)
                    {
                        A = 0;
                        AvgVal = 0;
                        while(A < KernelSize)
                        {
                            B = 0;
                            while(B < KernelSize)
                            {
                                AvgVal += Activations[X][Y + A][Z + B];

                                B++;
                            }

                            A++;
                        }

                        TempList.Add(AvgVal / (KernelSize * KernelSize));

                        Z +=KernelSize;
                    }

                    TempList2.Add(TempList);

                    Y +=KernelSize;
                }

                RetVal.Add(TempList2);

                X++;
            }

            

            return RetVal;
        }

        
        public List<double> ConcatVectors(List<double> Input1,List<double> Input2)
        {
            List<double> RetVal = new List<double>();
            int X = 0;

            while(X < Input1.Count)
            {
                RetVal.Add(Input1[X]);

                X++;
            }

            X = 0;
            while(X < Input2.Count)
            {
                RetVal.Add(Input2[X]);

                X++;
            }

            return RetVal;
        }

        public double[] Flatten3DVector(double[][][] Input)
        {
            //Normal: 2x63x63
            int X = 0;
            int Y = 0;
            int Z = 0;
            List<double> RetVal = new List<double>();
            double[] FinalRetVal;

            while(X < Input.Length)
            {
                Y = 0;
                while (Y < Input[X].Length)
                {
                    Z = 0;
                    while(Z < Input[X][Y].Length)
                    {
                        RetVal.Add(Input[X][Y][Z]);

                        Z++;
                    }

                    Y++;
                }

                X++;
            }

            FinalRetVal = new double[RetVal.Count];

            X = 0;
            while(X < RetVal.Count)
            {
                FinalRetVal[X] = RetVal[X];

                X++;
            }

            return FinalRetVal;
        }

        public double[] Flatten2DVector(double[][] Input)
        {
            int X = 0;
            int Y = 0;
            List<double> Output = new List<double>();
            double[] FinalOutput;

            while(X < Input.Length)
            {
                Y = 0;
                while(Y < Input[X].Length)
                {
                    Output.Add(Input[X][Y]);

                    Y++;
                }

                X++;
            }

            FinalOutput = new double[Output.Count];
            X = 0;
            while(X < Output.Count)
            {
                FinalOutput[X] = Output[X];

                X++;
            }


            return FinalOutput;
        }

        public double[][] Rotate2DMatrix180(double[][] Inputs)
        {
            double[][] Outputs = new double[Inputs.Length][];
            double[] TempList;
            int X = 0;
            int Y = 0;
            
            while(X < Inputs.Length)
            {
                TempList = new double[Inputs[X].Length];
                Y = 0;
                while(Y < Inputs[X].Length)
                {
                    TempList[Y] = (Inputs[Inputs.Length - 1 - X][Inputs[X].Length - 1 - Y]);

                    Y++;
                }

                Outputs[X] = TempList;

                X++;
            }
            
            return Outputs;
        }

        public Bitmap ArrayToBMP(double[][] Input,double ScaleConst = 255)
        {
            int ImageDim = Input.Length;
            Bitmap RetVal = new Bitmap(Input[0].Length, Input.Length);
            int X = 0;
            int Y = 0;
            int RGB = 0;
            int RVal = 0;
            int GVal = 0;
            int BVal = 0;
            int NewX = 0;
            int NewY = 0;
            double TempVal = 0;
            double MinVal = Input[0][0];

            X = 0;
            while (X < Input.Length)
            {
                Y = 0;
                while(Y < Input[X].Length)
                {
                    RVal = Math.Max(0, Math.Min(255, (int)(Math.Abs(Input[X][Y] * ScaleConst ))));
                    GVal = Math.Max(0, Math.Min(255, (int)(Math.Abs(Input[X][Y] * ScaleConst))));
                    BVal = Math.Max(0, Math.Min(255, (int)(Math.Abs(Input[X][Y] * ScaleConst ))));

                    RGB = RVal;

                    if(X < Input.Length && Y < Input[X].Length)
                    {
                        RetVal.SetPixel(Y, X, Color.FromArgb(RGB, RGB, RGB));
                    }
                    

                    Y++;
                }
                
               
                X++;
            }


            //Debug.Print(MinVal.ToString() + " - " + this.NeuralNetwork.MeanSquaredError.ToString());

            return RetVal;
        }

        public Bitmap ArrayToBMPTanH(double[][] Input)
        {
            int ImageDim = Input.Length;
            Bitmap RetVal = new Bitmap(ImageDim, ImageDim);
            int X = 0;
            int Y = 0;
            int RGB = 0;
            int RVal = 0;
            int GVal = 0;
            int BVal = 0;
            int NewX = 0;
            int NewY = 0;
            double TempVal = 0;
            double MinVal = Input[0][0];

            //Input = this.NormalizeDataSet(Input);

            X = 0;
            while (X < Input.Length)
            {
                Y = 0;
                while (Y < Input[X].Length)
                {
                    TempVal = Input[X][Y] + 1.0f;
                    TempVal = (TempVal / 2.0f);
                    TempVal *= 255;
                    RGB = (int)TempVal;

                    RGB = Math.Min(Math.Max(RGB, 0), 255);

                    RetVal.SetPixel(Y, X, Color.FromArgb(RGB, RGB, RGB));

                    Y++;
                }


                X++;
            }


            //Debug.Print(MinVal.ToString() + " - " + this.NeuralNetwork.MeanSquaredError.ToString());

            return RetVal;
        }

        public List<List<double>> BMPToArrayColor(Bitmap Input)
        {
            int X = 0;
            int Y = 0;
            int Z = 0;
            List<double> TempRow = new List<double>();
            List<List<double>> TempRow2 = new List<List<double>>();
            List<List<double>> RetVal = new List<List<double>>();

            Input = new Bitmap(Input, this.ImageDimensions, this.ImageDimensions);

            X = 0;
            TempRow2 = new List<List<double>>();
            while (X < Input.Height)
            {
                Y = 0;
                TempRow = new List<double>();
                while (Y < Input.Width)
                {
                    //TempRow.Add(((((Input.GetPixel(Y, X).R + Input.GetPixel(Y, X).G + Input.GetPixel(Y, X).B) / 3) * 0.001)));
                    TempRow.Add(Input.GetPixel(Y, X).R * 0.001);
                    TempRow.Add(Input.GetPixel(Y, X).G * 0.001);
                    TempRow.Add(Input.GetPixel(Y, X).B * 0.001);


                    Y++;
                }

                RetVal.Add(TempRow);

                X++;
            }

            return RetVal;
        }


        public double[][][] BMPToArray(Bitmap Input)
        {
            int X = 0;
            int Y = 0;
            int Z = 0;
            double TempVal = 0;
            double[] TempRow;
            double[][] TempRow2;
            double[][] RetVal;
            double[][][] FinalRetVal = new double[1][][];

            Input = new Bitmap(Input, this.ImageDimensions, this.ImageDimensions);

            X = 0;
            TempRow2 = new double[Input.Height][];
            while (X < Input.Height)
            {
                Y = 0;
                TempRow = new double[Input.Width];
                while (Y < Input.Width)
                {
                    //TempVal = (Input.GetPixel(Y, X).R + Input.GetPixel(Y, X).G + Input.GetPixel(Y, X).B) / 3.0f * 0.001f;
                    TempVal = (Input.GetPixel(Y, X).R + Input.GetPixel(Y, X).G + Input.GetPixel(Y, X).B) / 3.0f / 255.0f;
                    TempVal = TempVal * 2.0f - 1.0f;
                    TempRow[Y] = TempVal;

                    Y++;
                }

                TempRow2[X] = TempRow;

                X++;
            }

            FinalRetVal[0] = TempRow2;

            return FinalRetVal;
        }

        public double ReLU(double Input,bool LeakyReLU)
        {
            double TempVal = 0;

            if(LeakyReLU)
            {                
                if (Input > 0)
                {
                    TempVal = Input;
                }
                else
                {
                    TempVal = Input * this.NeuralNetwork.ReLUConst;
                }
            }
            else
            {
                if (Input > 0)
                {
                    TempVal = Input;
                }
                else
                {
                    TempVal = 0;
                }
            }
            

            return TempVal;
        }

        public double Sigmoid(double Input)
        {
            return 1 / (1 + Math.Pow(Math.E, -1 * Input));
        }
    }
}
