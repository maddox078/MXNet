using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms.VisualStyles;

namespace MaddoxNet2
{
    public class CNN
    {
        public ANN NeuralNet;
        public double[][][][] Filters;
        public double[][][][] LastFilters;
        public double[][][][] LastFilters2;
        public double[][][][] FeatureMaps;
        public double[][][][] NetFeatureMaps;
        public double[][][][] DerivativeFeatureMaps;
        public double[][][][] ErrorMaps;
        public double[][][][] DeltaMaps;
        public double[][] TransitionWeights;
        public double[][] TransitionWeightsDeltas;
        public double[][] LastTransitionWeights;
        public double[][] LastTransitionWeights2;
        public double[] TransitionValues;
        public double[] TransitionDerivatives;
        public int[] PoolingSchedule;
        public int[] FilterDimSchedule;
        public int[] ActivationFunctions;
        public int IterationCounter = 1;


        public CNN(int[] FeatureActivationIDs,int[] PoolingSched, int[] FilterCounts,int[] FilterDims,int ImageDims,int[] ANNLayerCounts, int[] ANNActivationIDs,double LearningRate)
        {
            int A = 0;
            int B = 0;
            int C = 0;
            int D = 0;
            double[] TempFilters1;
            double[][] TempFilters2;
            double[][][] TempFilters3;
            double[] TempFeatureMaps1;
            double[][] TempFeatureMaps2;
            double[][][] TempFeatureMaps3;
            double[] TempNetFeatureMaps1;
            double[][] TempNetFeatureMaps2;
            double[][][] TempNetFeatureMaps3;
            double[] TempDerivativeFeatureMaps1;
            double[][] TempDerivativeFeatureMaps2;
            double[][][] TempDerivativeFeatureMaps3;
            double[] TempDeltaMaps1;
            double[][] TempDeltaMaps2;
            double[][][] TempDeltaMaps3;
            double[] TempErrorMaps1;
            double[][] TempErrorMaps2;
            double[][][] TempErrorMaps3;
            double[] TempLastFilter1;
            double[][] TempLastFilter2;
            double[][][] TempLastFilter3;
            double[] TempLastFilter21;
            double[][] TempLastFilter22;
            double[][][] TempLastFilter23;
            double[] TempTransitionWeights;
            double[] TempTransitionWeightDeltas;
            double[] TempLastTransitionWeights;
            double[] TempLastTransitionWeights2;
            double TempImageDims = ImageDims;
            double TempPoolDims = ImageDims;
            Random Rnd = new Random(System.Guid.NewGuid().GetHashCode());

            this.PoolingSchedule = PoolingSched;
            this.ActivationFunctions = FeatureActivationIDs;
            this.NeuralNet = new ANN(ANNLayerCounts, ANNActivationIDs, LearningRate);
            this.FeatureMaps = new double[FilterCounts.Length][][][];
            this.NetFeatureMaps = new double[FilterCounts.Length][][][];
            this.DerivativeFeatureMaps = new double[FilterCounts.Length][][][];
            this.DeltaMaps = new double[FilterCounts.Length][][][];
            this.ErrorMaps = new double[FilterCounts.Length][][][];
            this.Filters = new double[FilterCounts.Length][][][];
            this.LastFilters = new double[FilterCounts.Length][][][];
            this.LastFilters2 = new double[FilterCounts.Length][][][];

            TempImageDims = ImageDims;
            TempPoolDims = TempImageDims;

            while (A < FilterCounts.Length)
            {
                TempFeatureMaps3 = new double[FilterCounts[A]][][];
                TempNetFeatureMaps3 = new double[FilterCounts[A]][][];
                TempDerivativeFeatureMaps3 = new double[FilterCounts[A]][][];
                TempErrorMaps3 = new double[FilterCounts[A]][][];                
                TempFilters3 = new double[FilterCounts[A]][][];
                TempDeltaMaps3 = new double[FilterCounts[A]][][];
                TempLastFilter3 = new double[FilterCounts[A]][][];
                TempLastFilter23 = new double[FilterCounts[A]][][];

                B = 0;
                while (B < FilterCounts[A])
                {
                    //Set up everything but filters
                    TempNetFeatureMaps2 = new double[(int)TempImageDims][];
                    TempDerivativeFeatureMaps2 = new double[(int)TempImageDims][];
                    TempErrorMaps2 = new double[(int)TempImageDims][];
                    

                    C = 0;
                    while (C < TempImageDims)
                    {
                        TempNetFeatureMaps1 = new double[(int)TempImageDims];
                        TempDerivativeFeatureMaps1 = new double[(int)TempImageDims];
                        TempErrorMaps1 = new double[(int)TempImageDims];

                        D = 0;
                        while (D < TempImageDims)
                        {
                            TempNetFeatureMaps1[D] = 0;
                            TempDerivativeFeatureMaps1[D] = 0;
                            TempErrorMaps1[D] = 0;

                            D++;
                        }

                        TempNetFeatureMaps2[C] = TempNetFeatureMaps1;
                        TempDerivativeFeatureMaps2[C] = TempDerivativeFeatureMaps1;
                        TempErrorMaps2[C] = TempErrorMaps1;

                        C++;
                    }

                    TempNetFeatureMaps3[B] = TempNetFeatureMaps2;
                    TempDerivativeFeatureMaps3[B] = TempDerivativeFeatureMaps2;
                    TempErrorMaps3[B] = TempErrorMaps2;

                    //Set up post pooling feature maps
                    TempPoolDims = (int)(TempImageDims / this.PoolingSchedule[A]);

                    TempFeatureMaps2 = new double[(int)TempPoolDims][];

                    C = 0;
                    while (C < TempPoolDims)
                    {
                        TempFeatureMaps1 = new double[(int)TempPoolDims];

                        D = 0;
                        while (D < TempPoolDims)
                        {
                            TempFeatureMaps1[D] = 0;

                            D++;
                        }

                        TempFeatureMaps2[C] = TempFeatureMaps1;

                        C++;
                    }

                    TempFeatureMaps3[B] = TempFeatureMaps2;

                    //Set up filters
                    TempFilters2 = new double[FilterDims[A]][];
                    TempLastFilter2 = new double[FilterDims[A]][];
                    TempLastFilter22 = new double[FilterDims[A]][];
                    TempDeltaMaps2 = new double[FilterDims[A]][];

                    C = 0;
                    while (C < FilterDims[A])
                    {
                        TempFilters1 = new double[FilterDims[A]];
                        TempLastFilter1 = new double[FilterDims[A]];
                        TempLastFilter21 = new double[FilterDims[A]];
                        TempDeltaMaps1 = new double[FilterDims[A]];

                        D = 0;
                        while (D < FilterDims[A])
                        {
                            TempFilters1[D] =(0.05* (Math.Sqrt(-2.0 * Math.Log(1.0 - Rnd.NextDouble())) * Math.Cos(2.0 * Math.PI * (1.0 - Rnd.NextDouble()))));
                            //TempFilters1[D] = Rnd.NextDouble()  % 0.1;
                            TempLastFilter1[D] = 0;
                            TempLastFilter21[D] = 0;
                            TempDeltaMaps1[D] = 0;

                            D++;
                        }

                        TempFilters2[C] = TempFilters1;
                        TempLastFilter2[C] = TempLastFilter1;
                        TempLastFilter22[C] = TempLastFilter21;
                        TempDeltaMaps2[C] = TempDeltaMaps1;

                        C++;
                    }

                    TempFilters3[B] = TempFilters2;
                    TempLastFilter3[B] = TempLastFilter2;
                    TempLastFilter23[B] = TempLastFilter22;
                    TempDeltaMaps3[B] = TempDeltaMaps2;

                    B++;
                }

                this.FeatureMaps[A] = TempFeatureMaps3;
                this.NetFeatureMaps[A] = TempNetFeatureMaps3;
                this.DerivativeFeatureMaps[A] = TempDerivativeFeatureMaps3;
                this.ErrorMaps[A] = TempErrorMaps3;
                this.DeltaMaps[A] = TempDeltaMaps3;
                this.Filters[A] = TempFilters3;
                this.LastFilters[A] = TempLastFilter3;
                this.LastFilters2[A] = TempLastFilter23;

                TempImageDims = TempPoolDims;

                A++;
            }

            this.TransitionWeightsDeltas = new double[this.NeuralNet.Activations[0].Length][];
            this.TransitionWeights = new double[this.NeuralNet.Activations[0].Length][];
            this.LastTransitionWeights = new double[this.NeuralNet.Activations[0].Length][];
            this.LastTransitionWeights2 = new double[this.NeuralNet.Activations[0].Length][];
            this.TransitionValues = new double[this.NeuralNet.Activations[0].Length];
            this.TransitionDerivatives = new double[this.NeuralNet.Activations[0].Length];

            A = 0;
            while (A < this.NeuralNet.Activations[0].Length)
            {
                TempTransitionWeights = new double[(int)(this.FeatureMaps[this.FeatureMaps.Length - 1].Length * (Math.Pow(this.FeatureMaps[this.FeatureMaps.Length - 1][0].Length, 2)))];
                TempTransitionWeightDeltas = new double[(int)(this.FeatureMaps[this.FeatureMaps.Length - 1].Length * (Math.Pow(this.FeatureMaps[this.FeatureMaps.Length - 1][0].Length, 2)))];
                TempLastTransitionWeights = new double[(int)(this.FeatureMaps[this.FeatureMaps.Length - 1].Length * (Math.Pow(this.FeatureMaps[this.FeatureMaps.Length - 1][0].Length, 2)))];
                TempLastTransitionWeights2 = new double[(int)(this.FeatureMaps[this.FeatureMaps.Length - 1].Length * (Math.Pow(this.FeatureMaps[this.FeatureMaps.Length - 1][0].Length, 2)))];

                B = 0;
                while (B < (this.FeatureMaps[this.FeatureMaps.Length - 1].Length * (Math.Pow(this.FeatureMaps[this.FeatureMaps.Length - 1][0].Length, 2))))
                {
                    TempTransitionWeights[B] = 0.05 * (Math.Sqrt(-2.0 * Math.Log(1.0 - Rnd.NextDouble())) * Math.Cos(2.0 * Math.PI * (1.0 - Rnd.NextDouble())));
                    //TempTransitionWeights[B] = Rnd.NextDouble();
                    TempLastTransitionWeights[B] = 0;
                    TempLastTransitionWeights2[B] = 0;
                    TempTransitionWeightDeltas[B] = 0;

                    B++;
                }

                this.TransitionWeights[A] = TempTransitionWeights;
                this.LastTransitionWeights[A] = TempLastTransitionWeights;
                this.LastTransitionWeights2[A] = TempLastTransitionWeights2;
                this.TransitionValues[A] = 0;
                this.TransitionDerivatives[A] = 0;
                this.TransitionWeightsDeltas[A] = TempTransitionWeightDeltas;

                A++;
            }
            
        }

        public void ForwardPropagate(double[][] Inputs)
        {
            int A = 0;
            int B = 0;
            double[][][] ConvolveList = new double[1][][];
            double[] TempTransitionValues1;
            double[] TempTransitionValues2;
            double[] FlattenedValues;
            double TempVal = 0;

            ConvolveList[0] = Inputs;

            while(A < this.Filters.Length)
            {
                if(A == 0)
                {
                    this.NetFeatureMaps[A] = this.Convolve(ConvolveList, this.Filters[A],A, this.PoolingSchedule[A], ((this.Filters[A][0].Length - 1) / 2));
                }
                else
                {
                    this.NetFeatureMaps[A] = this.Convolve(this.FeatureMaps[A - 1], this.Filters[A],A, this.PoolingSchedule[A], ((this.Filters[A][0].Length - 1) / 2));
                }

                this.DerivativeFeatureMaps[A] = this.ActivateDerivativeConvolutions((this.NetFeatureMaps[A]), this.ActivationFunctions[A]);
                this.FeatureMaps[A] = this.ActivateConvolutions((this.NetFeatureMaps[A]), this.ActivationFunctions[A]);

                A++;
            }

            FlattenedValues = this.Flatten3DVector(this.FeatureMaps[this.FeatureMaps.Length - 1]);
            TempTransitionValues1 = new double[this.NeuralNet.Activations[0].Length];
            TempTransitionValues2 = new double[this.NeuralNet.Activations[0].Length];

            A = 0;
            while(A < this.NeuralNet.Activations[0].Length)
            {
                TempVal = 0;

                B = 0;
                while (B < FlattenedValues.Length)
                {
                    TempVal += (this.TransitionWeights[A][B] * FlattenedValues[B]);

                    B++;
                }

                TempTransitionValues1[A] = (TempVal);
                TempTransitionValues2[A] = this.NeuralNet.ActivationFunctionDerivative(TempVal, 2);

                A++;
            }

            //this.TransitionNetInputs = TempTransitionValues1;
            this.TransitionValues = TempTransitionValues1;
            this.TransitionDerivatives = TempTransitionValues2;

            this.NeuralNet.ForwardPropagate(this.TransitionValues);
        }

        public void BackPropagate(double[][] Inputs,double[] Outputs, int OptimizerID, bool TrainWeights = true,bool TrainFilters = true)
        {
            int A = 0;
            int B = 0;
            int C = 0;
            int D = 0;
            double[] FlattenedFeatures;
            double[] FlattenedDerivatives;
            double[] TransitionValues1;
            double[][] TransitionValues2;
            double[][][] TransitionValues3;
            double[][][] NeuronGradients = new double[0][][];
            double[][][] FilterGradients;
            double[][][] BackpropErrors = new double[0][][];
            double[][][] LocalGradients = new double[1][][];
            double TempVal = 0;
            int NeuronIndex = 0;
            double Delta;



            LocalGradients[0] = Inputs;

            this.ForwardPropagate(Inputs);

            this.NeuralNet.BackPropagate(this.TransitionValues, Outputs, OptimizerID, TrainWeights);

            TransitionValues1 = new double[this.Flatten3DVector(this.FeatureMaps[this.FeatureMaps.Length - 1]).Length];

            FlattenedFeatures = this.Flatten3DVector(this.FeatureMaps[this.FeatureMaps.Length - 1]);
            FlattenedDerivatives = this.Flatten3DVector(this.DerivativeFeatureMaps[this.DerivativeFeatureMaps.Length - 1]);

            A = 0;
            while(A < FlattenedFeatures.Length)
            {
                TempVal = 0;
                        
                D = 0;
                while (D < this.NeuralNet.Activations[0].Length)
                {                            
                    TempVal += (this.NeuralNet.Errors[0][D] * this.TransitionWeights[D][A]);

                    D++;
                }

                TransitionValues1[A] = TempVal;

                A++;
            }



            NeuronIndex = 0;
            while(NeuronIndex < this.TransitionWeights.Length)
            { 
                D = 0;
                while (D < this.TransitionWeights[NeuronIndex].Length)
                {
                    if (TrainWeights)
                        {
                            switch (OptimizerID)
                            {
                                case 0:
                                    TempVal = (this.NeuralNet.LearningRate * (this.NeuralNet.Errors[0][NeuronIndex] * this.NeuralNet.Derivatives[0][NeuronIndex] * FlattenedFeatures[D]));
                                    this.TransitionWeights[NeuronIndex][D] -= (TempVal + (0.9 * this.LastTransitionWeights[NeuronIndex][D]));
                                    this.LastTransitionWeights[NeuronIndex][D] = TempVal;

                                    break;
                                case 1:
                                    Delta = (this.NeuralNet.Errors[0][NeuronIndex] * this.NeuralNet.Derivatives[0][NeuronIndex] * FlattenedFeatures[D]);
                                    this.LastTransitionWeights[NeuronIndex][D] = (this.NeuralNet.B1 * this.LastTransitionWeights[NeuronIndex][D] + (1.0 - this.NeuralNet.B1) * (Math.Pow(Delta, 2)));
                                    TempVal = (this.NeuralNet.LearningRate * Delta / Math.Sqrt(this.LastTransitionWeights[NeuronIndex][D] + 0.000000001));
                                    this.TransitionWeights[NeuronIndex][D] -= TempVal;


                                this.TransitionWeightsDeltas[NeuronIndex][D] = TempVal;

                                    break;
                                case 2:
                                    Delta = (this.NeuralNet.Errors[0][NeuronIndex] * this.NeuralNet.Derivatives[0][NeuronIndex] * FlattenedFeatures[D]);
                                    this.LastTransitionWeights[NeuronIndex][D] = (this.NeuralNet.B1 * this.LastTransitionWeights[NeuronIndex][D]) + ((1.0 - this.NeuralNet.B1) * (Delta));/// (1.0 - Math.Pow(this.NeuralNet.B1, this.IterationCounter));
                                    this.LastTransitionWeights2[NeuronIndex][D] = (this.NeuralNet.B2 * this.LastTransitionWeights2[NeuronIndex][D]) + ((1.0 - this.NeuralNet.B2) * Math.Pow(Delta, 2));// / (1.0 - Math.Pow(this.NeuralNet.B2, this.IterationCounter));
                                    TempVal = (this.NeuralNet.LearningRate * this.LastTransitionWeights[NeuronIndex][D] / (Math.Sqrt(this.LastTransitionWeights2[NeuronIndex][D]) + 0.00000001));
                                    this.TransitionWeights[NeuronIndex][D] -= TempVal;

                                    this.TransitionWeightsDeltas[NeuronIndex][D] = TempVal;

                                    break;

                            }

                        }

                    D++;
                }


                NeuronIndex++;
            }


            ///////////////
            ///

            A = this.Filters.Length - 1;

            while(A >= 0)
            {
                if(A == this.Filters.Length - 1)
                {
                    //NeuronGradients = this.ElementWiseMultiply1D(TransitionValues1, this.TransitionDerivatives);
                    NeuronGradients = this.ReshapeTensor(TransitionValues1, this.DerivativeFeatureMaps[A].Length);
                    NeuronGradients = this.ElementWiseMultiply(NeuronGradients, this.DerivativeFeatureMaps[A]);
                    //NeuronGradients = this.TransposedConvolution3(NeuronGradients, this.Filters[A], A, this.FeatureMaps[A][0].Length, this.FeatureMaps[A].Length, true, true);


                    FilterGradients = this.TransposedConvolution3(this.FeatureMaps[A - 1], NeuronGradients, A,this.Filters[A][0].Length,this.Filters[A].Length,true, true);
                    
                    BackpropErrors = this.TransposedConvolution3(NeuronGradients, this.Filters[A - 1], A,this.FeatureMaps[A-1][0].Length,this.Filters[A-1].Length,true,true);
                }
                else
                {
                    NeuronGradients = BackpropErrors;

                    if (A == 0)
                    {
                        LocalGradients = new double[1][][];
                        LocalGradients[0] = Inputs;

                        NeuronGradients = this.ElementWiseMultiply(NeuronGradients, this.DerivativeFeatureMaps[A]);
                        
                        FilterGradients = this.TransposedConvolution3(LocalGradients, NeuronGradients, A, this.Filters[A][0].Length, this.Filters[A].Length, true, true);
                    }
                    else
                    {
                        NeuronGradients = this.ElementWiseMultiply(NeuronGradients, this.DerivativeFeatureMaps[A]);
                        
                        FilterGradients = this.TransposedConvolution3(this.FeatureMaps[A - 1], NeuronGradients, A,this.Filters[A][0].Length,this.Filters[A].Length, true, true);

                        BackpropErrors = this.TransposedConvolution3(NeuronGradients, this.Filters[A - 1], A,this.FeatureMaps[A-1][0].Length,this.FeatureMaps[A-1].Length, true,true);
                    }
                }
                
                this.ErrorMaps[A] = NeuronGradients;

                if (TrainFilters)
                {
                    B = 0;
                    while (B < this.Filters[A].Length)
                    {
                        C = 0;
                        while(C < this.Filters[A][B].Length)
                        {
                            D = 0;
                            while (D < this.Filters[A][B][C].Length)
                            {
                                switch (OptimizerID)
                                {
                                    case 0:
                                        TempVal = (this.NeuralNet.LearningRate * FilterGradients[B][C][D]);
                                        this.Filters[A][B][C][D] -= (TempVal + (0.9 * this.LastFilters[A][B][C][D]));
                                        this.LastFilters[A][B][C][D] = TempVal;

                                        break;
                                    case 1:
                                        this.LastFilters[A][B][C][D] = (this.NeuralNet.B1 * this.LastFilters[A][B][C][D] + (1.0 - this.NeuralNet.B1) * (Math.Pow((FilterGradients[B][C][D]), 2)));
                                        TempVal = (this.NeuralNet.LearningRate * FilterGradients[B][C][D] / Math.Sqrt(this.LastFilters[A][B][C][D] + 0.000000001) );
                                        this.Filters[A][B][C][D] -= TempVal;

                                        this.DeltaMaps[A][B][C][D] = TempVal;
                                       
                                        break;
                                    case 2:
                                        this.LastFilters[A][B][C][D] = (this.NeuralNet.B1 * this.LastFilters[A][B][C][D]) + ((1.0 - this.NeuralNet.B1) * FilterGradients[B][C][D]);// / (1.0 - Math.Pow(this.NeuralNet.B1, this.IterationCounter));
                                        this.LastFilters2[A][B][C][D] = (this.NeuralNet.B2 * this.LastFilters2[A][B][C][D]) + ((1.0 - this.NeuralNet.B2) * Math.Pow(FilterGradients[B][C][D], 2));/// (1.0 - Math.Pow(this.NeuralNet.B2, this.IterationCounter));
                                        TempVal = (this.NeuralNet.LearningRate * this.LastFilters[A][B][C][D] / (Math.Sqrt(this.LastFilters2[A][B][C][D]) + 0.000000001));
                                        this.Filters[A][B][C][D] -= TempVal;

                                        this.DeltaMaps[A][B][C][D] = TempVal;

                                        break;
                                }                                

                                D++;
                            }

                            C++;
                        }

                        B++;
                    }
                }

                A--;
            }

            this.IterationCounter++;
        }

        private double[][][] ReshapeTensor(double[] Input, int MapCount)
        {
            List<List<double>> TempMap = new List<List<double>>();
            List<List<List<double>>> Output = new List<List<List<double>>>();
            List<double> TempList = new List<double>();

            double[][][] FinalOutput;
            double[][] FinalTempMap;
            double[] FinalTempList;

            int X = 0;
            int Y = 0;
            int Z = 0;
            int MapDimensions = (int)Math.Sqrt((int)(Input.Length / MapCount));

            while (X < Input.Length)
            {
                if (X > 0 && X % MapDimensions == 0)
                {
                    TempMap.Add(TempList);
                    TempList = new List<double>();
                }

                if (TempMap.Count > 0 && TempMap.Count % MapDimensions == 0)
                {
                    Output.Add(TempMap);
                    TempMap = new List<List<double>>();
                }

                TempList.Add(Input[X]);

                X++;
            }

            while (TempList.Count < MapDimensions)
            {
                TempList.Add(0);
            }

            TempMap.Add(TempList);

            while (TempMap.Count < MapDimensions)
            {
                TempList = new List<double>();
                Y = 0;
                while (Y < MapDimensions)
                {
                    TempList.Add(0);

                    Y++;
                }

                TempMap.Add(TempList);
            }

            Output.Add(TempMap);

            FinalOutput = new double[Output.Count][][];
            X = 0;
            while (X < Output.Count)
            {
                FinalTempMap = new double[Output[X].Count][];
                Y = 0;
                while (Y < Output[X].Count)
                {
                    FinalTempList = new double[Output[X][Y].Count];
                    Z = 0;
                    while (Z < Output[X][Y].Count)
                    {
                        FinalTempList[Z] = Output[X][Y][Z];

                        Z++;
                    }

                    FinalTempMap[Y] = FinalTempList;

                    Y++;
                }

                FinalOutput[X] = FinalTempMap;

                X++;
            }

            return FinalOutput;
        }

        public double[][][] ResolveAveragePooling(double[][][] InputLayer, int LayerID)
        {
            double[][][] RetVal = new double[InputLayer.Length][][];
            double[][] TempMap;
            int X = 0;
            int Y = 0;
            int Z = 0;
            int A = 0;
            int B = 0;
            double GradientVal = 0;

            //LayerID = Math.Max(0,LayerID-1);

            if (this.PoolingSchedule[LayerID] == 1)
            {
                return InputLayer;
            }

            while (X < InputLayer.Length)
            {
                TempMap = this.CreateEmptyMap(this.NetFeatureMaps[LayerID][0].Length * this.PoolingSchedule[LayerID]);
                Y = 0;
                while (Y < InputLayer[X].Length)
                {
                    Z = 0;
                    while (Z < InputLayer[X][Y].Length)
                    {
                        A = 0;
                        while (A < this.PoolingSchedule[LayerID])
                        {
                            B = 0;
                            while (B < this.PoolingSchedule[LayerID])
                            {
                                if (Y * this.PoolingSchedule[LayerID] + A < TempMap.Length && Z * this.PoolingSchedule[LayerID] + B < TempMap.Length)
                                {
                                    TempMap[Y * this.PoolingSchedule[LayerID] + A][Z * this.PoolingSchedule[LayerID] + B] += (InputLayer[X][Y][Z]);
                                }

                                B++;
                            }

                            A++;
                        }


                        Z++;
                    }

                    Y++;
                }

                RetVal[X] = TempMap;

                X++;
            }

            TempMap = null;

            return RetVal;
        }

        public double[][] CreateEmptyMap(int Dimensions, double InitializationVal = 0)
        {
            double[] SubOutput = new double[Dimensions];
            double[][] Output = new double[Dimensions][];
            int X = 0;
            int Y = 0;

            while (X < Dimensions)
            {
                SubOutput = new double[Dimensions];
                Y = 0;
                while (Y < Dimensions)
                {
                    SubOutput[Y] = InitializationVal;

                    Y++;
                }

                Output[X] = SubOutput;

                X++;
            }

            return Output;
        }

        public double[][][] CreateEmptyMapList(int Dimensions,int MapCount, double InitializationVal = 0)
        {
            double[] SubOutput = new double[Dimensions];
            double[][] Output = new double[Dimensions][];
            double[][][] FinalOutput = new double[MapCount][][];
            int X = 0;
            int Y = 0;
            int Z = 0;

            while(Z < MapCount)
            {
                Output = new double[Dimensions][];
                X = 0;
                while (X < Dimensions)
                {
                    SubOutput = new double[Dimensions];
                    Y = 0;
                    while (Y < Dimensions)
                    {
                        SubOutput[Y] = InitializationVal;

                        Y++;
                    }

                    Output[X] = SubOutput;

                    X++;
                }

                FinalOutput[Z] = Output;

                Z++;
            }


            return FinalOutput;
        }

        public double[][][] ElementWiseMultiply(double[][][] Input1, double[][][] Input2)
        {
            double[] SubSubRetVal;
            double[][] SubRetVal;
            double[][][] RetVal = new double[Math.Max(Input2.Length,Input1.Length)][][];
            int X = 0;
            int Y = 0;
            int Z = 0;

            while (X < Input1.Length)
            {
                SubRetVal = new double[Input1[X].Length][];
                Y = 0;
                while (Y < Input1[X].Length)
                {
                    SubSubRetVal = new double[Input1[X][Y].Length];
                    Z = 0;
                    while (Z < Input1[X][Y].Length)
                    {
                        if (X < Input1.Length && Y < Input1[0].Length && Z < Input2[0][0].Length && Y < Input2[0].Length)
                        {
                            SubSubRetVal[Z] = (Input1[X][Y][Z] * Input2[X][Y][Z]);
                        }
                        else
                        {
                            SubSubRetVal[Z] = 0;
                        }

                        Z++;
                    }

                    SubRetVal[Y] = SubSubRetVal;

                    Y++;
                }

                RetVal[X] = SubRetVal;

                X++;
            }

            return RetVal;
        }

        public double[] ElementWiseMultiply1D(double[] Input1, double[] Input2)
        {
            double[] Output = new double[Input1.Length];
            int X = 0;

            while(X < Input1.Length)
            {
                Output[X] = Input1[X] * Input2[X];

                X++;
            }

            return Output;
        }

        private double[] Flatten3DVector(double[][][] Input)
        {
            int X = 0;
            int Y = 0;
            int Z = 0;
            List<double> RetVal = new List<double>();
            double[] FinalRetVal;

            while (X < Input.Length)
            {
                Y = 0;
                while (Y < Input[X].Length)
                {
                    Z = 0;
                    while (Z < Input[X][Y].Length)
                    {
                        RetVal.Add(Input[X][Y][Z]);

                        Z++;
                    }

                    Y++;
                }

                X++;
            }

            FinalRetVal = new double[RetVal.Count];

            X = 0;
            while (X < RetVal.Count)
            {
                FinalRetVal[X] = RetVal[X];

                X++;
            }

            return FinalRetVal;
        }


        public double[][][] PoolLayer(double[][][] Input, int LayerID)
        {
            int X = 0;
            int Y = 0;
            int Z = 0;
            int A = 0;
            int B = 0;
            double AvgVal = 0;
            double[][] TempVals2;
            double[] TempVals;
            double[][][] FinalRetVal;

            FinalRetVal = new double[Input.Length][][];

            while (Z < Input.Length)
            {
                TempVals2 = new double[(int)(Input[Z].Length / (this.PoolingSchedule[LayerID]))][];
                X = 0;
                while (X < Input[Z].Length - this.PoolingSchedule[LayerID] + 1)
                {
                    TempVals = new double[(int)(Input[Z][X].Length / (this.PoolingSchedule[LayerID]))];
                    Y = 0;
                    while (Y < Input[Z][X].Length - this.PoolingSchedule[LayerID] + 1)
                    {
                        AvgVal = 0;
                        A = 0;
                        while (A < this.PoolingSchedule[LayerID])
                        {
                            B = 0;
                            while (B < this.PoolingSchedule[LayerID])
                            {
                                AvgVal += Input[Z][X + A][Y + B];

                                B++;
                            }

                            A++;
                        }

                        AvgVal /= (this.PoolingSchedule[LayerID] * this.PoolingSchedule[LayerID]);

                        TempVals[Y / this.PoolingSchedule[LayerID]] = AvgVal;

                        Y += this.PoolingSchedule[LayerID];
                    }

                    TempVals2[X / this.PoolingSchedule[LayerID]] = TempVals;

                    X += this.PoolingSchedule[LayerID];
                }

                FinalRetVal[Z] = TempVals2;

                Z++;
            }

            return FinalRetVal;
        }

        public double[][][] ActivateConvolutions(double[][][] Input, int ActivationID)
        {
            int X = 0;
            int Y = 0;
            int Z = 0;
            double[][][] Output = new double[Input.Length][][];
            double[][] TempList2;
            double[] TempList;

            while (X < Input.Length)
            {
                TempList2 = new double[Input[X].Length][];
                Y = 0;
                while (Y < Input[X].Length)
                {
                    TempList = new double[Input[X][Y].Length];
                    Z = 0;
                    while (Z < Input[X][Y].Length)
                    {
                        double TempVal = 0.0f;

                        switch (ActivationID)
                        {
                            //TanH
                            case 0:
                                TempVal = Math.Tanh(Input[X][Y][Z]);

                                break;
                            //Sigmoid
                            case 1:
                                TempVal = 1 / (1 + Math.Pow(Math.E, -1 * Input[X][Y][Z]));

                                break;
                            case 2:
                                if (Input[X][Y][Z] > 0)
                                {
                                    TempVal = Input[X][Y][Z];
                                }
                                else
                                {
                                    TempVal = 0.9 * (Math.Exp(Input[X][Y][Z]) - 1.0);
                                }
                                break;
                            //ReLU
                            case 3:
                                if (Input[X][Y][Z] >= 0)
                                {
                                    TempVal = Input[X][Y][Z];
                                }
                                else
                                {
                                    //TempVal = this.ReLUConst * Input[X][Y][Z];
                                }

                                break;
                            //Swish
                            case 4:
                                //TempVal = Input[X][Y][Z] * this.ActivationFunction(Input[X][Y][Z], 1);
                                break;
                            case 9:
                                TempVal = Input[X][Y][Z];
                                break;
                        }

                        TempList[Z] = TempVal;

                        Z++;
                    }

                    TempList2[Y] = TempList;

                    Y++;
                }

                Output[X] = TempList2;

                X++;
            }


            return Output;
        }

        public double[][][] ActivateDerivativeConvolutions(double[][][] Input, int ActivationID)
        {
            int X = 0;
            int Y = 0;
            int Z = 0;
            double[][][] Output = new double[Input.Length][][];
            double[][] TempList2;
            double[] TempList;

            while (X < Input.Length)
            {
                TempList2 = new double[Input[X].Length][];
                Y = 0;
                while (Y < Input[X].Length)
                {
                    TempList = new double[Input[X][Y].Length];
                    Z = 0;
                    while (Z < Input[X][Y].Length)
                    {
                        double TempVal = 0.0f;

                        switch (ActivationID)
                        {
                            //TanH
                            case 0:
                                TempVal = Math.Tanh(Input[X][Y][Z]);
                                TempVal = (1.0 - (TempVal * TempVal));

                                break;
                            //Sigmoid
                            case 1:
                                //TempVal = this.ActivationFunction(Input[X][Y][Z], 1);
                                //TempVal = TempVal * (1 - TempVal);

                                break;
                            case 2:
                                if (Input[X][Y][Z] > 0)
                                {
                                    TempVal = 1;
                                }
                                else
                                {
                                    TempVal = 0.9 * Math.Exp(Input[X][Y][Z]);
                                }

                                break;
                            //ReLU
                            case 3:
                                if (Input[X][Y][Z] >= 0)
                                {
                                    TempVal = 1;
                                }
                                else
                                {
                                    //TempVal = 0;
                                    //TempVal = this.ReLUConst;
                                }

                                break;
                            //Swish
                            case 4:
                                //TempVal = ActivationFunction(Input[X][Y][Z], 1);
                                //TempVal = TempVal + Input[X][Y][Z] * TempVal * (1.0 - TempVal);

                                break;
                            case 9:
                                TempVal = Input[X][Y][Z];
                                break;
                        }
                        
                        TempList[Z] = TempVal;

                        Z++;
                    }

                    TempList2[Y] = TempList;

                    Y++;
                }

                Output[X] = TempList2;

                X++;
            }


            return Output;
        }


        public double[][][] Convolve(double[][][] Features, double[][][] Filters,int LayerID,double Stride = 1,double Padding = 0, bool RotateFilters = false)
        {
            int A = 0;
            int B = 0;
            int C = 0;
            int D = 0;
            int E = 0;
            int F = 0;
            int X = 0;
            int Y = 0;
            double[][][] NewFilters = new double[Filters.Length][][];
            double[][][] NewFeatures;
            double[] Outputs1;
            double[][] Outputs2;
            double[][][] Outputs3;
            double[][] SummedMap = new double[0][];
            double TempVal;

            if(RotateFilters)
            {
                A = 0;
                while (A < Filters.Length)
                {
                    NewFilters[A] = this.Rotate2DMatrix180(Filters[A]);

                    A++;
                }
            }
            else
            {
                NewFilters = Filters;
            }

            NewFeatures = Features;

            Outputs3 = this.CreateEmptyMapList(Features[0].Length / this.PoolingSchedule[LayerID], NewFilters.Length);

            //Padding = 0;

            X = 0;
            while(X < NewFilters.Length)
            {
                A = 0;
                while(A < Outputs3[0].Length)
                {
                    B = 0;
                    while (B < Outputs3[0][0].Length)
                    {
                        TempVal = 0;
                        Y = 0;
                        while (Y < NewFeatures.Length)
                        {
                            //TempVal = 0;
                            E = 0;
                            while (E < NewFilters[X].Length)
                            {
                                F = 0;
                                while (F < NewFilters[X].Length)
                                {
                                    if ((A * Stride + E) < NewFeatures[Y].Length && (B * Stride + F) < NewFeatures[Y].Length)
                                    {
                                        TempVal += (NewFilters[X][E][F] * NewFeatures[Y][(int)(A * Stride + E)][(int)(B * Stride + F)]);
                                    }

                                    F++;
                                }

                                E++;
                            }

                            Y++;
                        }

                        Outputs3[X][A][B] = TempVal;

                        B++;
                    }

                    A++;
                }

                X++;
            }

            return Outputs3;
        }

        private double[][] ElementWiseSummation(double[][] Input1, double[][] Input2)
        {
            double[] SubSubRetVal;
            double[][] SubRetVal = new double[Input1.Length][];
            int X = 0;
            int Y = 0;

            while (X < Input1.Length)
            {
                SubSubRetVal = new double[Input1[X].Length];
                Y = 0;
                while (Y < Input1[X].Length)
                {
                    SubSubRetVal[Y] = (Input1[X][Y] + Input2[X][Y]);

                    Y++;
                }

                SubRetVal[X] = SubSubRetVal;

                X++;
            }

            return SubRetVal;
        }


        public double[][][] TransposedConvolution3(double[][][] Features, double[][][] Gradients,int LayerID, int OutputDims,int OutputCount,bool PadFeatures = true,bool RotateGradients = true)
        {
            int A = 0;
            int B = 0;
            int C = 0;
            int X = 0;
            int Y = 0;
            int U = 0;
            int V = 0;
            int TempX = 0;
            int TempY = 0;
            double[][][] Output = new double[OutputCount][][];
            double[] TempList1;
            double[][] TempList2;
            double[][][] NewFilters = new double[Gradients.Length][][];
            double[][][] NewFeatures = new double[Features.Length][][];
            double TempVal = 0;

            //LayerID = LayerID - 1;

            //if (PadFeatures)
            //{
            //    NewFeatures = this.PadLayerMaps(Features, (Gradients[0].Length - 1) / 2);
            //}
            //else
            //{
                NewFeatures = Features;
            //}


            if (RotateGradients)
            {
                U = 0;
                while (U < Gradients.Length)
                {
                    NewFilters[U] = this.Rotate2DMatrix180(Gradients[U]);

                    U++;
                }
            }
            else
            {
                NewFilters = Gradients;
            }
            

            //Output = this.CreateEmptyMapList(Features[0].Length, NewFilters.Length);
            Output = this.CreateEmptyMapList(OutputDims, OutputCount);

            //NewFeatures = this.PadLayerMaps(Features, (int)((Output[0].Length -1) / 2));

            U = 0;
            while (U < NewFilters.Length)
            {
                A = 0;
                while (A < NewFeatures.Length)
                {
                    B = 0;
                    while (B < NewFeatures[A].Length)
                    {
                        C = 0;
                        while (C < NewFeatures[A][B].Length)
                        {
                            X = 0;
                            while (X <  NewFilters[U].Length)
                            {
                                Y = 0;
                                while (Y < NewFilters[U][X].Length)
                                {
                                    if((B * this.PoolingSchedule[LayerID] + X) < Output[U].Length && (C * this.PoolingSchedule[LayerID] + Y) < Output[U].Length)
                                    {
                                        Output[U][(B * this.PoolingSchedule[LayerID] + X)][(C * this.PoolingSchedule[LayerID] + Y)] += (NewFeatures[A][B][C] * NewFilters[U][X][Y]);
                                    }


                                    Y++;
                                }

                                X++;
                            }

                            C++;
                        }

                        B++;
                    }

                    A++;
                }

                //Output[U] = TempList2;

                U++;
            }


            return Output;
        }



        private double[][] Rotate2DMatrix180(double[][] Inputs)
        {
            double[][] Outputs = new double[Inputs.Length][];
            double[] TempList;
            int X = 0;
            int Y = 0;

            while (X < Inputs.Length)
            {
                TempList = new double[Inputs[X].Length];
                Y = 0;
                while (Y < Inputs[X].Length)
                {
                    TempList[Y] = (Inputs[Inputs.Length - 1 - X][Inputs[X].Length - 1 - Y]);

                    Y++;
                }

                Outputs[X] = TempList;

                X++;
            }

            return Outputs;
        }


        public double[][][] PadLayerMaps(double[][][] InputLayerMaps, int PaddingSize)
        {
            double[][][] RetVal = new double[InputLayerMaps.Length][][];
            int X = 0;

            while (X < InputLayerMaps.Length)
            {
                RetVal[X] = PadMap(InputLayerMaps[X], PaddingSize);

                X++;
            }

            return RetVal;
        }

        public double[][] PadMap(double[][] InputMap, int PaddingSize)
        {
            double[] TempList1;
            double[][] TempList2 = new double[InputMap.Length + (2 * PaddingSize)][];
            int X = 0;
            int Y = 0;

            while (X < InputMap.Length + (2 * PaddingSize))
            {
                TempList1 = new double[InputMap.Length + (2 * PaddingSize)];
                Y = 0;
                while (Y < InputMap.Length + (2 * PaddingSize))
                {
                    TempList1[Y] = 0;

                    Y++;
                }

                TempList2[X] = TempList1;

                X++;
            }

            X = 0;
            while (X < InputMap.Length)
            {
                Y = 0;
                while (Y < InputMap[X].Length)
                {
                    TempList2[X + PaddingSize][Y + PaddingSize] = InputMap[X][Y];

                    Y++;
                }

                X++;
            }

            return TempList2;
        }
    }
}
